{"version":3,"sources":["formation/PlanePosition.ts","drawing/AbstractDrawer.ts","store/types.ts","constants.ts","geometry/Polar.ts","drawing/PlanesDrawer.ts","drawing/FormationDrawer.ts","components/FormationComponent.tsx","util/approxeq.ts","formation/lapwrapper.ts","formation/lap.js","formation/slotify.ts","formation/buildSlots.ts","formation/components/Component.ts","formation/components/Round.ts","formation/components/Whacker.ts","formation/components/Base.ts","formation/AbstractSlotCollection.ts","formation/buildFormation.ts","selectors/getSlotOptions.ts","formation/planes.ts","formation/buildPlanes.ts","selectors/index.ts","formation/planeify.ts","components/FormationContainer.ts","components/config/Slots.tsx","store/actions.ts","components/config/Planes.tsx","components/config/View.tsx","components/ConfigMenu.tsx","serviceWorker.js","store/reducer.ts","index.tsx","components/App.tsx"],"names":["PlanePosition","AbstractDrawer","group","this","Slotting","PlaneType","ColorOption","NumberOption","ShowOption","FormationType","PI","Math","TAU","Polar","radius","theta","Object","classCallCheck","unspin","concat","other","r1","t1","r2","t2","sqrt","cos","atan2","sin","plus","rotate","minus","s","floor","x","d","y","w","otterPoints","doorPoints","l","line","d3","addPlane","g","positionToCoordinate","call","gg","attr","_ref","position","plane","get","selection","append","text","_ref2","selectAll","data","_ref3","slots","map","objectSpread","planeSlotId","formationSlotId","toString","join","enter","slotG","update","select","exit","remove","PlanesDrawer","args","_planesAndCoordinates","_ref4","planes","show","viewConfig","formation","FORMATION","Map","PLANES","positions","p","LT","LEAD","RT","filter","includes","idx","all","offset","length","abs","BOTH","_ref5","planesAndCoordinates","slottedPlanes","id","_ref6","planeId","planeGrps","sp","transition","duration","arc","dockAngle","scaledPos","scale","outerRadius","innerRadius","startAngle","d3theta","endAngle","translate","addSlot","fill","label","style","transitionSlot","oldData","changedSlots","i","nodes","old","each","slotNum","push","delays","sort","reduce","acc","delay","FormationDrawer","_ref3$viewConfig","colorBy","numberBy","slotData","numColors","Set","buildOrder","size","DEFAULT","BUILD_ORDER","domain","stop","PLANE","_","SLOT_NUM","slotGroups","set","t","FormationComponent","svg","allGrp","zoom","formationDrawer","planesDrawer","parseInt","_this2","scaleExtent","on","transform","translateBy","width","height","withGroup","draw","props","_this3","react_default","a","createElement","ref","element","React","Component","approxeq","b","eps","arguments","undefined","Number","EPSILON","lapwrapper","as","bs","scoreFun","Error","result","dim","cost","cost_matrix","j","i1","j1","sum","unassignedfound","imin","prvnumfree","f","i0","k","freerow","j2","endofpath","last","low","up","min","h","umin","usubmin","v2","BIG","epsilon","rowsol","Int32Array","colsol","u","Float64Array","v","numfree","free","collist","matches","pred","loopcnt","lapcost","row","col","lap","memo","key","has","Array","from","slotPlane","formationSlotIds","filledSlots","slot","reverseBuildOrder","jr","slotJr","slicedToArray","slotNumOffset","checkSlot","slotPosition","waiting","_this","range","pos","rotation","max","apply","toConsumableArray","parents","parent","maxBuildOrder","Round","left","right","possibleConstructorReturn","getPrototypeOf","firstRun","_prrd","c","prrd","ceil","_positionRadiusRotationDockAngle","dockPosition","leftDockPosition","rightDockPosition","dockDistance","distanceFrom","_Round$__computeRadiu","__computeRadiusTheta","angleDelta","angleTo","console","error","iters","iter","lower","upper","mid","ss","Whacker","dock","hand","_this$dock","_this$dock2","psuedoSlots","_left","_right","invisibleSlots","_this$_prrd","fixedRotation","Base","_rotation","AbstractSlotCollection","_slots","computeSlots","slotsInRing","baseSize","ring","podLines","round","bridges","addRings","rings","completeRings","nextRingSlots","dockPositions","base","keys","component","isPod","firstPods","numBridges","bridgeNum","secondPods","bridgeSecondPods","flatMap","secondPod","nextDockPositions","slotsPerGroup","groupsWithExtraSlot","nextRing","groupNum","slotsToFill","totalSlotsInGroup","priorSlots","leftHandSlots","rightHandSlots","whackers","FormationImpl","components","allSlots","parentToChildren","child","forEach","componentToWaiting","children","numWaiting","find","slotRadi","createSelector","state","formationConfig","planesConfig","_planesConfig$filter$","type","NONE","slotting","planeMin","FILL","planeMax","fixedMin","Otter","_AbstractPlane","_getPrototypeOf2","_len","_key","jrOffset","inherits","createClass","value","floaters","inDoor","inDoor2","divers","AbstractPlane","countFilledSlots","filledPlanes","_ref10","_ref11","slotUnfilledPlanes","unfilledPlanes","slotsRemaining","slotsPerPlane","lead","littlePlanes","littlePlaneLabels","_ref7","minSlotsPerPlane","extras","filledLead","_ref8","remainingFilled","_ref9","_ref12","getSlots","getSlotOptions","getBaseSize","getFormation","flat","getPlanes","slotsMap","_ref13","_ref14","OTTER","SKYVAN","planeFactory","getAllSlots","planeAssignments","slotify","_slotted$","slotted","baseIds","unslotted","planeArray","remainigToFill","slotId","diff","componentTheta","componentPosition","penalty","slotIds","planeify","connect","slotsOptions","dispatch","onFormationSlotsSet","formationSlots","onBaseSizeSet","_props$slotsOptions","trigger","Icon","name","Dropdown","pointing","className","Menu","Item","onChange","e","target","onClick","active","PlaneMenu","_slottingDescriptions","planeConfig","setters","onPlaneSlottingSet","onPlaneTypeSet","onPlaneSlotsSet","types","SPLIT","slottingDescriptions","defineProperty","slottings","fluid","Header","Divider","planeType","setPlaneType","setPlaneSlots","setPlaneSlotting","numPlanes","item","Planes_PlaneMenu","onSetColorBy","setColorBy","onSetNumberBy","setNumberBy","onSetShow","setShow","colorBys","opt","desc","numberBys","ConfigMenu","secondary","config_Slots","config_Planes","config_View","Boolean","window","location","hostname","match","initialPlaneState","rootReducer","combineReducers","action","HD","formationType","store","createStore","reducer","composeWithDevTools","ReactDOM","render","es","Container","marginTop","FormationContainer","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.f442d7f7.chunk.js","sourcesContent":["enum PlanePosition {\n    LEAD='lead',\n    LT = 'lt',\n    RT = 'rt'\n}\n\nexport default PlanePosition","import Drawer from \"./interfaces\"\n\nexport default abstract class AbstractDrawer<Args, ReturnArgs>\n  implements Drawer<Args, ReturnArgs> {\n  group!: d3.Selection<SVGGElement, {}, null, undefined>\n\n  withGroup(group: d3.Selection<SVGGElement, {}, null, undefined>): this {\n    this.group = group\n    return this\n  }\n\n  abstract draw(args: Args): ReturnArgs\n}\n","import PlanePosition from \"../formation/PlanePosition\"\n\nexport enum Slotting {\n  SPLIT = \"Split\",\n  FILL = \"Fill\"\n}\n\nexport enum PlaneType {\n  NONE = \"None\",\n  OTTER = \"Otter\",\n  SKYVAN = \"Skyvan\"\n}\n\nexport enum ColorOption {\n  DEFAULT = \"DEFAULT\",\n  PLANE = \"PLANE\",\n  BUILD_ORDER = \"BUILD_ORDER\"\n}\n\nexport enum NumberOption {\n  SLOT_NUM = \"SLOT_NUM\",\n  BUILD_ORDER = \"BUILD_ORDER\"\n}\n\nexport enum ShowOption {\n  FORMATION = \"Formation\",\n  PLANES = \"Planes\",\n  BOTH = \"Formation & planes\"\n}\n\nexport enum FormationType {\n  HD = \"HD\",\n  SD = \"SD\"\n}\n\nexport interface PlaneState {\n  position: PlanePosition\n  label: string\n  slotting: Slotting\n  type: PlaneType\n  slots: number\n}\n\nexport interface FormationConfigState {\n  slots: number\n  baseSize: number\n  type: FormationType\n}\n\nexport interface ViewConfigState {\n  colorBy: ColorOption\n  numberBy: NumberOption\n  show: ShowOption\n}\n\nexport const SET_PLANE_SLOTTING = \"SET_PLANE_SLOTTING\"\ninterface SetPlaneSlottingAction {\n  type: typeof SET_PLANE_SLOTTING\n  position: PlanePosition\n  slotting: Slotting\n}\n\nexport const SET_PLANE_TYPE = \"SET_PLANE_TYPE\"\ninterface SetPlaneTypeAction {\n  type: typeof SET_PLANE_TYPE\n  position: PlanePosition\n  planeType: PlaneType\n}\n\nexport const SET_PLANE_SLOTS = \"SET_PLANE_SLOTS\"\ninterface SetPlaneSlotsAction {\n  type: typeof SET_PLANE_SLOTS\n  position: PlanePosition\n  slots: number\n}\nexport type PlanesConfigActionTypes =\n  | SetPlaneSlottingAction\n  | SetPlaneTypeAction\n  | SetPlaneSlotsAction\n\nexport const SET_FORMATION_SLOTS = \"SET_FORMATION_SLOTS\"\ninterface SetFormationSlotsAction {\n  type: typeof SET_FORMATION_SLOTS\n  slots: number\n}\nexport const SET_FORMATION_TYPE = \"SET_FORMATION_TYPE\"\ninterface SetFormationTypeAction {\n  type: typeof SET_FORMATION_TYPE\n  formationType: FormationType\n}\nexport const SET_BASE_SIZE = \"SET_BASE_SIZE\"\ninterface SetBaseSizeAction {\n  type: typeof SET_BASE_SIZE\n  baseSize: number\n}\nexport type FormationConfigActionTypes =\n  | SetFormationSlotsAction\n  | SetFormationTypeAction\n  | SetBaseSizeAction\n\nexport const SET_COLOR_BY = \"SET_COLOR_BY\"\ninterface SetColorByAction {\n  type: typeof SET_COLOR_BY\n  colorBy: ColorOption\n}\nexport const SET_NUMBER_BY = \"SET_NUMBER_BY\"\ninterface SetNumberByAction {\n  type: typeof SET_NUMBER_BY\n  numberBy: NumberOption\n}\n\nexport const SET_SHOW = \"SET_SHOW\"\ninterface SetShowAction {\n  type: typeof SET_SHOW\n  show: ShowOption\n}\nexport type ViewConfigActionTypes =\n  | SetColorByAction\n  | SetNumberByAction\n  | SetShowAction\n","export const PI = Math.PI\nexport const TAU = 2 * PI\nexport const SCALE_FACTOR = 80\n","import {PI, TAU} from '../constants'\n\n// polar coordinate from origin (center of base)\nexport default class Polar {\n  radius: number;\n  theta: number;\n    constructor(radius: number, theta: number) {\n      this.radius=radius\n      this.theta=Polar.unspin(theta)\n    }\n    \n    toString() {\n      return `(r${this.radius},∠${this.theta/TAU}τ)`\n    }\n    \n    //https://math.stackexchange.com/questions/1365622/adding-two-polar-vectors\n    plus(other: Polar) {\n      const {radius: r1, theta: t1} = this\n      const {radius: r2, theta: t2} = other\n      return new Polar(\n        Math.sqrt(r1*r1 + r2*r2 + 2*r1*r2*Math.cos(t2-t1)),\n        t1 + Math.atan2(r2 * Math.sin(t2-t1), r1 + r2 * Math.cos(t2-t1))\n      )\n    }\n    \n    minus(other: Polar) {\n      return this.plus(other.rotate(PI))\n    }\n    \n    rotate(theta: number) {\n      return new Polar(this.radius, this.theta + theta)\n    }\n    \n    // distance from other point\n    distanceFrom(other: Polar) {\n      return this.minus(other).radius\n    }\n    \n    angleFrom(other: Polar) {\n      return this.minus(other).theta\n    }\n    \n    angleTo(other: Polar) {\n      return other.minus(this).theta\n    }\n    \n    scale(s: number) {\n      return new Polar(this.radius * s, this.theta)\n    }\n    \n    // d3 treats theta = 0 as up, but in high school, theta = 0 is right\n    // also, d3 treats increasing theta as rotating clockwise, hs went counter clock wise\n    // this maps a highschool polar angle to a d3 polar angle\n    get d3theta() {\n      return Polar.unspin(-this.theta + PI/2)\n    }\n    \n    get x() {\n      return this.radius * Math.cos(this.theta)\n    }\n    \n    //svg treats positive y as going down from top of page\n    get y() {\n      return - this.radius * Math.sin(this.theta)\n    }\n    \n    // map theta back to [0, 2PI)\n    static unspin(theta: number) {\n      const t = Math.floor(theta / (2 * PI))\n      return theta - (t * 2 * PI)\n    }\n  }","import {\n  Plane,\n  Slot,\n  PlaneSlot,\n  Formation,\n  FormationSlot\n} from \"../formation/interfaces\"\nimport AbstractDrawer from \"./AbstractDrawer\"\nimport * as d3 from \"d3\"\nimport PlanePosition from \"../formation/PlanePosition\"\nimport { ViewConfigState, ShowOption } from \"../store/types\"\nimport Polar from \"../geometry/Polar\"\nimport { PI, SCALE_FACTOR, TAU } from \"../constants\"\n\ntype XY = {\n  x: number;\n  y: number;\n}\n\ninterface SlottedPlane {\n  plane: Plane\n  slots: Slot[]\n}\n\nconst x = (d: XY) => d.x * 40\nconst y = (d: XY) => d.y * 40\n\nconst w = 1.5\nconst l = 6\nconst otterPoints = [\n  { x: -w, y: -l - 1 },\n  { x: w, y: -l - 1 },\n  { x: w, y: l },\n  { x: -w, y: l },\n  { x: -w, y: -l - 1 }\n]\n\nconst doorPoints = [{ x: -w, y: l - 6 }, { x: -w, y: l - 2 }]\n\nconst line = d3\n  .line<XY>()\n  .x(x)\n  .y(y)\n\n/**\n *\n * @param g a selection (of g)\n * @param fill function mapping slotData to a fill color\n * @param label function mapping slotData to a label\n */\nconst addPlane = (\n  g: d3.Transition<SVGGElement, SlottedPlane, SVGGElement, {}>,\n  positionToCoordinate: Map<PlanePosition, Polar>\n) => {\n  g.call(gg =>\n    gg.attr(\n      \"transform\",\n      ({ plane: { position } }) =>\n        `translate(${positionToCoordinate.get(position)!.x}, ${\n          positionToCoordinate.get(position)!.y\n        }) scale(1)`\n    )\n  )\n    .selection()\n    .call(gg => gg.append(\"path\").attr(\"d\", line(otterPoints)!))\n    .call(gg =>\n      gg\n        .append(\"path\")\n        .attr(\"stroke-width\", 3)\n        .attr(\"d\", line(doorPoints)!)\n    )\n    .call(gg =>\n      gg\n        .append(\"text\")\n        .attr(\"text-anchor\", \"middle\")\n        .attr(\"dominant-baseline\", \"central\")\n        .attr(\"x\", 0)\n        .attr(\"y\", -260)\n        .text(({ plane: { position } }) => position)\n    )\n    .selectAll<SVGGElement, PlaneSlot & Slot>(\"g\")\n    .data<PlaneSlot & Slot>(\n      ({ plane, slots }) =>\n        slots.map(s => ({\n          ...s,\n          ...plane.slots[s.planeSlotId]\n        })),\n      d => d.formationSlotId.toString()\n    )\n    .join(\n      enter =>\n        enter\n          .append(\"g\")\n          .call(slotG =>\n            slotG\n              .append(\"circle\")\n              .attr(\"cx\", x)\n              .attr(\"cy\", y)\n              .attr(\"r\", 16)\n          )\n          .call(slotG =>\n            slotG\n              .append(\"text\")\n              .attr(\"text-anchor\", \"middle\")\n              .attr(\"dominant-baseline\", \"central\")\n              .attr(\"x\", x)\n              .attr(\"y\", y)\n              // .text(d => d.jr)\n              .text(d => d.formationSlotId + 1)\n          ),\n      update =>\n        update\n          .call(update =>\n            update\n              .select(\"circle\")\n              .attr(\"cx\", x)\n              .attr(\"cy\", y)\n          )\n          .call(update =>\n            update\n              .select(\"text\")\n              .attr(\"x\", x)\n              .attr(\"y\", y)\n          ),\n      exit => exit.remove()\n    )\n}\ntype PlanesAndCoordinates = {\n  planes: Plane[];\n  positionToCoordinate: Map<PlanePosition, Polar>;\n}\nconst planesAndCoordinates = ({\n  planes,\n  viewConfig: { show },\n  formation: { radius }\n}: PlanesArgs): PlanesAndCoordinates => {\n  switch (show) {\n    case ShowOption.FORMATION:\n      return { planes: [], positionToCoordinate: new Map() }\n    case ShowOption.PLANES: {\n      const positions = planes.map(p => p.position)\n      const positionToCoordinate = new Map(\n        [PlanePosition.LT, PlanePosition.LEAD, PlanePosition.RT]\n          .filter(p => positions.includes(p))\n          .map((p, idx, all) => {\n            const offset = idx * 300 - (all.length - 1) * 150\n            return [p, new Polar(Math.abs(offset), offset >= 0 ? 0 : PI)]\n          })\n      )\n      return { planes, positionToCoordinate }\n    }\n    case ShowOption.BOTH: {\n      const positionToCoordinate = new Map(\n        planes.map(({ position, theta }) => {\n          return [\n            position,\n            new Polar(\n              (radius + 3) * SCALE_FACTOR,\n              position === PlanePosition.LEAD ? TAU / 12 : theta\n            )\n          ]\n        })\n      )\n      return { planes, positionToCoordinate }\n    }\n  }\n}\n\ninterface PlanesArgs {\n  slots: Slot[]\n  planes: Plane[]\n  formation: Formation\n  viewConfig: ViewConfigState\n}\nexport default class PlanesDrawer extends AbstractDrawer<PlanesArgs, void> {\n  draw(args: PlanesArgs) {\n    const { planes, positionToCoordinate } = planesAndCoordinates(args)\n\n    const slottedPlanes: SlottedPlane[] = planes.map((plane, id) => ({\n      plane,\n      slots: args.slots.filter(({ planeId }) => id === planeId)\n    }))\n\n    const planeGrps = this.group\n      .selectAll<SVGGElement, SlottedPlane>(\"g.plane\")\n      .data(slottedPlanes, sp => sp.plane.position)\n\n    planeGrps\n      .transition()\n      .duration(1000)\n      .call(addPlane, positionToCoordinate)\n\n    planeGrps\n      .enter()\n      .append(\"g\")\n      .attr(\"class\", \"plane\")\n      .attr(\"transform\", \"translate(0,0) scale(0)\")\n      .transition()\n      .duration(1000)\n      .call(addPlane, positionToCoordinate)\n\n    planeGrps\n      .exit()\n      .transition()\n      .duration(1000)\n      .attr(\"transform\", \"translate(0,0) scale(0)\")\n      .remove()\n  }\n}\n\n//     protected computeSlots(): PlaneSlot[] {\n\n//     }\n","import {\n  Plane,\n  Formation,\n  Slot,\n  FormationSlot,\n  NumDict\n} from \"../formation/interfaces\"\nimport PlanePosition from \"../formation/PlanePosition\"\nimport * as d3 from \"d3\"\nimport AbstractDrawer from \"./AbstractDrawer\"\nimport { ViewConfigState, ShowOption } from \"../store/types\"\nimport { SCALE_FACTOR } from \"../constants\"\n\ninterface SlotData extends FormationSlot {\n  slotNum: number\n  plane: PlanePosition\n}\n\ntype StringDict<V> = { [index: string]: V }\n\ntype SlotDataFun = (d: SlotData) => any\n\nconst stringRange = (stop: number): string[] =>\n  d3.range(stop).map(x => x.toString())\n\nconst arc = ({ position, dockAngle }: SlotData) => {\n  const scaledPos = position.scale(SCALE_FACTOR)\n  return d3.arc()({\n    outerRadius: scaledPos.radius,\n    innerRadius: scaledPos.radius,\n    startAngle: scaledPos.d3theta - dockAngle,\n    endAngle: scaledPos.d3theta + dockAngle\n  })\n}\n\n// const arc = (d: SlotData) => arcFun(d)()\nconst x = (d: SlotData) => d.position.scale(SCALE_FACTOR).x\nconst y = (d: SlotData) => d.position.scale(SCALE_FACTOR).y\nconst translate = (d: SlotData) =>\n  `translate(${d.offset.scale(SCALE_FACTOR).x},${\n    d.offset.scale(SCALE_FACTOR).y\n  })`\n\n/**\n *\n * @param g a selection (of g)\n * @param fill function mapping slotData to a fill color\n * @param label function mapping slotData to a label\n */\nconst addSlot = (\n  g: d3.Selection<SVGGElement, SlotData, SVGGElement, {}>,\n  fill: SlotDataFun,\n  label: SlotDataFun\n) => {\n  g.append(\"path\")\n    .attr(\"class\", \"grips\")\n    .attr(\"d\", arc)\n\n  g.append(\"circle\")\n    .attr(\"cx\", x)\n    .attr(\"cy\", y)\n    .attr(\"r\", 16)\n    .style(\"fill\", (d: SlotData) => fill(d))\n\n  g.append(\"text\")\n    .attr(\"text-anchor\", \"middle\")\n    .attr(\"dominant-baseline\", \"central\")\n    .attr(\"x\", x)\n    .attr(\"y\", y)\n    .text(label)\n}\n\n/**\n *\n * @param g a selection (of g)\n * @param fill function mapping slotData to a fill color\n * @param label function mapping slotData to a label\n * @param oldData a d3.local of values of data before transition\n */\nconst transitionSlot = (\n  g: d3.Transition<SVGGElement, SlotData, SVGGElement, {}>,\n  fill: SlotDataFun,\n  label: SlotDataFun,\n  oldData: d3.Local<SlotData>\n) => {\n  const changed = (\n    d: SlotData,\n    i: number,\n    nodes: ArrayLike<SVGGElement>\n  ): boolean => {\n    const old = oldData.get(nodes[i])!\n    return x(d) !== x(old) || y(d) !== y(old)\n  }\n  const changedSlots = [] as number[]\n\n  g.filter(changed).each(({ slotNum }) => changedSlots.push(slotNum))\n\n  const delays = changedSlots.sort().reduce(\n    (acc, s, i) => {\n      acc[s] = i\n      return acc\n    },\n    {} as NumDict<number>\n  )\n\n  const gg = g.delay((d: SlotData) => delays[d.slotNum] * 10 || 0)\n  gg.attr(\"transform\", (d: SlotData) => translate(d) + \" scale(1)\")\n\n  gg.select(\"path\").attr(\"d\", arc)\n\n  gg.select(\"circle\")\n    .attr(\"cx\", x)\n    .attr(\"cy\", y)\n    .style(\"fill\", fill)\n\n  gg.select(\"text\")\n    .attr(\"x\", x)\n    .attr(\"y\", y)\n    .text(label)\n}\n\ninterface FormationArgs {\n  slots: Slot[]\n  formation: Formation\n  planes: Plane[]\n  viewConfig: ViewConfigState\n}\nexport default class FormationDrawer extends AbstractDrawer<\n  FormationArgs,\n  void\n> {\n  draw({\n    formation,\n    planes,\n    slots,\n    viewConfig: { colorBy, numberBy, show }\n  }: FormationArgs) {\n    const slotData: SlotData[] =\n      show === ShowOption.PLANES\n        ? []\n        : slots.map(({ formationSlotId, planeId }) => ({\n            slotNum: formationSlotId,\n            ...formation.slots[formationSlotId],\n            plane: planes[planeId].position\n          }))\n\n    const numColors = new Set(slotData.map((d: SlotData) => d.buildOrder)).size\n\n    const buildOrderFill = (d: SlotData) =>\n      d3.scaleOrdinal(d3.schemePaired).domain(stringRange(numColors))(\n        (d.buildOrder - 1).toString()\n      )\n    const planeFill = (d: SlotData) =>\n      d3\n        .scaleOrdinal(d3.schemePaired.filter((_, i) => [0, 2, 4].includes(i)))\n        .domain([PlanePosition.LEAD, PlanePosition.LT, PlanePosition.RT])(\n        d.plane\n      )\n\n    const fills: StringDict<SlotDataFun> = {\n      DEFAULT: () => null,\n      BUILD_ORDER: buildOrderFill,\n      PLANE: planeFill\n    }\n\n    const fill = fills[colorBy]\n\n    const labels: StringDict<SlotDataFun> = {\n      SLOT_NUM: (d: SlotData) => d.slotNum + 1,\n      BUILD_ORDER: (d: SlotData) => d.buildOrder\n    }\n\n    const label = labels[numberBy]\n\n    const oldData = d3.local() as d3.Local<SlotData>\n\n    const slotGroups = this.group\n      .selectAll<SVGGElement, SlotData>(\"g.slot\")\n      .each((d, i, nodes) => {\n        oldData.set(nodes[i], d)\n      })\n      .data<SlotData>(slotData, d => d.slotNum.toString())\n    // .data<SlotData>(slotData, d=> d.slotNum)\n    // (slotData, ((d: SlotData) => d.slotNum))\n\n    const t = d3.transition().duration(1000)\n\n    slotGroups.transition(t as any).call(transitionSlot, fill, label, oldData)\n\n    slotGroups\n      .enter()\n      .append(\"g\")\n      .attr(\"class\", \"slot\")\n      .attr(\"transform\", \"translate(0,0) scale(0)\")\n      .transition(t as any)\n      .attr(\"transform\", (d: SlotData) => translate(d) + \" scale(1)\")\n      .selection()\n      .call(addSlot, fill, label)\n\n    slotGroups\n      .exit()\n      .transition(t as any)\n      .attr(\"transform\", \"translate(0,0) scale(0)\")\n      .remove()\n\n    // const s = (Math.min(this.height(), this.width()) / 2) / ((formation.radius + 0.5)) / 94\n\n    // // d3.zoomIdentity.translate()\n    // const recenter = d3.zoomTransform(this.svg as any)\n    //     .translate(this.width() / 2, this.height() / 2)\n    //     .scale(s)\n    // this.svg.transition(t as any).call(this.zoom.transform as any, recenter)\n  }\n}\n","import React from \"react\"\nimport * as d3 from \"d3\"\nimport \"./FormationComponent.css\"\n\nimport { Formation, Plane, Slot } from \"../formation/interfaces\"\nimport PlanesDrawer from \"../drawing/PlanesDrawer\"\nimport { ViewConfigState } from \"../store/types\"\nimport FormationDrawer from \"../drawing/FormationDrawer\"\n\ninterface FormationProps {\n  formation: Formation\n  planes: Plane[]\n  slots: Slot[]\n  viewConfig: ViewConfigState\n}\nexport default class FormationComponent extends React.Component<\n  FormationProps,\n  {}\n> {\n  svg!: d3.Selection<SVGSVGElement, {}, null, undefined>\n  allGrp!: d3.Selection<SVGGElement, {}, null, undefined>\n  zoom!: d3.ZoomBehavior<SVGSVGElement, {}>\n  formationDrawer!: FormationDrawer\n  planesDrawer!: PlanesDrawer\n\n  height() {\n    return parseInt(this.svg.style(\"height\"), 10)\n  }\n\n  width() {\n    return parseInt(this.svg.style(\"width\"), 10)\n  }\n\n  componentDidMount() {\n    this.allGrp = this.svg.append(\"g\")\n\n    this.zoom = d3\n      .zoom<SVGSVGElement, {}>()\n      .scaleExtent([0.5, 2])\n      .on(\"zoom\", () => this.allGrp.attr(\"transform\", d3.event.transform))\n\n    this.svg\n      .call(this.zoom) //allows user zoom\n      .call(this.zoom.translateBy, this.width() / 2, this.height() / 2) //set initial zoom  to center\n\n    //bounding box\n    // https://bl.ocks.org/iamkevinv/0a24e9126cd2fa6b283c6f2d774b69a2\n\n    this.formationDrawer = new FormationDrawer().withGroup(\n      this.allGrp.append(\"g\")\n    )\n    this.formationDrawer.draw(this.props)\n    this.planesDrawer = new PlanesDrawer().withGroup(this.allGrp.append(\"g\"))\n    this.planesDrawer.draw(this.props)\n  }\n\n  componentDidUpdate() {\n    this.formationDrawer.draw(this.props)\n    this.planesDrawer.draw(this.props)\n  }\n\n  render() {\n    return (\n      <svg\n        width={\"100%\"}\n        height={\"100%\"}\n        ref={element => (this.svg = d3.select(element!))}\n      />\n    )\n  }\n}\n","export default function approxeq(\n  a: number,\n  b: number,\n  eps = Math.sqrt(Number.EPSILON)\n) {\n  return Math.abs(a - b) < eps\n}\n","import lap from \"./lap\"\n\n//takes a scoreFun that takes an A and a B\n//and converts it to a function that takes i, j for i, j in [0, number of as/bs)\n//for use with lap()\nfunction cost<A, B>(as: A[], bs: B[], scoreFun: (a: A, b: B) => number) {\n  //memoize scoreFun\n  const memo = new Map<string, number>()\n  return (i: number, j: number): number => {\n    const key = `${i}.${j}`\n    if (!memo.has(key)) {\n      const a = as[i]\n      const b = bs[j]\n      memo.set(key, scoreFun(a, b))\n    }\n    return memo.get(key)!\n  }\n}\n\n/**\n * takes two arrays of things of equal length and a function that computes a score between a pair of those things\n * and assigns each thing in the first list to a thing in the second list, minimizing the sum of the scores of the assigned pairs\n * an\n * @param as\n * @param bs\n * @param scoreFun\n */\nfunction lapwrapper<A, B>(\n  as: A[],\n  bs: B[],\n  scoreFun: (a: A, b: B) => number\n): [A, B][] {\n  if (as.length !== bs.length) {\n    throw new Error(\"as and bs have diff lenghts\")\n  }\n\n  const result = lap(as.length, cost(as, bs, scoreFun))\n  // const assignments = result.col\n\n  // return Array.from(assignments).map((p: number, i: number) => {\n  //   const a = as[p]\n  //   const b = bs[i]\n  //   return [a, b]\n  // })\n\n  return Array.from(result.row).map((p: number, i: number) => {\n    const a = as[i]\n    const b = bs[p]\n    return [a, b]\n  })\n}\n\nexport default lapwrapper\n","//https://github.com/Fil/lap-jv\n/************************************************************************\n*\n*  lap.js -- ported to javascript from\n\n   lap.cpp\n   version 1.0 - 4 September 1996\n   author: Roy Jonker @ MagicLogic Optimization Inc.\n   e-mail: roy_jonker@magiclogic.com\n\n   Code for Linear Assignment Problem, according to\n\n   \"A Shortest Augmenting Path Algorithm for Dense and Sparse Linear\n    Assignment Problems,\" Computing 38, 325-340, 1987\n\n   by\n\n   R. Jonker and A. Volgenant, University of Amsterdam.\n\n*\n   PORTED TO JAVASCRIPT 2017-01-02 by Philippe Riviere(fil@rezo.net)\n   CHANGED 2016-05-13 by Yang Yong(yangyongeducation@163.com) in column reduction part according to\n   matlab version of LAPJV algorithm(Copyright (c) 2010, Yi Cao All rights reserved)--\n   https://www.mathworks.com/matlabcentral/fileexchange/26836-lapjv-jonker-volgenant-algorithm-for-linear-assignment-problem-v3-0:\n*\n*************************************************************************/\n\n/* This function is the jv shortest augmenting path algorithm to solve the assignment problem */\nexport default function lap(dim, cost) {\n  // input:\n  // dim        - problem size\n  // cost       - cost callback (or matrix)\n\n  // output:\n  // rowsol     - column assigned to row in solution\n  // colsol     - row assigned to column in solution\n  // u          - dual variables, row reduction numbers\n  // v          - dual variables, column reduction numbers\n\n  // convert the cost matrix (old API) to a callback (new API)\n  if (typeof cost === \"object\") {\n    var cost_matrix = cost;\n    cost = function (i, j) {\n      return cost_matrix[i][j];\n    };\n  }\n\n  var sum = 0;\n  {\n    let i1, j1;\n    for (i1 = 0; i1 < dim; i1++) {\n      for (j1 = 0; j1 < dim; j1++)\n        sum += cost(i1, j1);\n    }\n  }\n  const BIG = 10000 * (sum / dim);\n  const epsilon = sum / dim / 10000;\n  const rowsol = new Int32Array(dim),\n    colsol = new Int32Array(dim),\n    u = new Float64Array(dim),\n    v = new Float64Array(dim);\n  let unassignedfound;\n  /* row */\n  let i, imin, numfree = 0, prvnumfree, f, i0, k, freerow; // *pred, *free\n  /* col */\n  let j, j1, j2, endofpath, last, low, up; // *collist, *matches\n  /* cost */\n  let min, h, umin, usubmin, v2; // *d\n\n  const free = new Int32Array(dim); // list of unassigned rows.\n  const collist = new Int32Array(dim); // list of columns to be scanned in various ways.\n  const matches = new Int32Array(dim); // counts how many times a row could be assigned.\n  const d = new Float64Array(dim); // 'cost-distance' in augmenting path calculation.\n  const pred = new Int32Array(dim); // row-predecessor of column in augmenting/alternating path.\n\n  // init how many times a row will be assigned in the column reduction.\n  for (i = 0; i < dim; i++)\n    matches[i] = 0;\n\n  // COLUMN REDUCTION\n  for (\n    j = dim;\n    j--; // reverse order gives better results.\n\n  ) {\n    // find minimum cost over rows.\n    min = cost(0, j);\n    imin = 0;\n    for (i = 1; i < dim; i++)\n      if (cost(i, j) < min) {\n        min = cost(i, j);\n        imin = i;\n      }\n    v[j] = min;\n    if (++matches[imin] === 1) {\n      // init assignment if minimum row assigned for first time.\n      rowsol[imin] = j;\n      colsol[j] = imin;\n    } else if (v[j] < v[rowsol[imin]]) {\n      j1 = rowsol[imin];\n      rowsol[imin] = j;\n      colsol[j] = imin;\n      colsol[j1] = -1;\n    } else colsol[j] = -1; // row already assigned, column not assigned.\n  }\n\n  // REDUCTION TRANSFER\n  for (i = 0; i < dim; i++) {\n    if (\n      matches[i] === 0 // fill list of unassigned 'free' rows.\n    )\n      free[numfree++] = i;\n    else if (matches[i] === 1) {\n      // transfer reduction from rows that are assigned once.\n      j1 = rowsol[i];\n      min = BIG;\n      for (j = 0; j < dim; j++)\n        if (j !== j1)\n          if (cost(i, j) - v[j] < min + epsilon) min = cost(i, j) - v[j];\n      v[j1] = v[j1] - min;\n    }\n  }\n\n  // AUGMENTING ROW REDUCTION\n  let loopcnt = 0; // do-loop to be done twice.\n  do {\n    loopcnt++;\n\n    // scan all free rows.\n    // in some cases, a free row may be replaced with another one to be scanned next.\n    k = 0;\n    prvnumfree = numfree;\n    numfree = 0; // start list of rows still free after augmenting row reduction.\n    while (k < prvnumfree) {\n      i = free[k];\n      k++;\n\n      // find minimum and second minimum reduced cost over columns.\n      umin = cost(i, 0) - v[0];\n      j1 = 0;\n      usubmin = BIG;\n      for (j = 1; j < dim; j++) {\n        h = cost(i, j) - v[j];\n        if (h < usubmin)\n          if (h >= umin) {\n            usubmin = h;\n            j2 = j;\n          } else {\n            usubmin = umin;\n            umin = h;\n            j2 = j1;\n            j1 = j;\n          }\n      }\n\n      i0 = colsol[j1];\n      if (umin < usubmin + epsilon)\n        //         change the reduction of the minimum column to increase the minimum\n        //         reduced cost in the row to the subminimum.\n        v[j1] = v[j1] - (usubmin + epsilon - umin);\n      else if (i0 > -1) {\n        // minimum and subminimum equal.\n        // minimum column j1 is assigned.\n        // swap columns j1 and j2, as j2 may be unassigned.\n        j1 = j2;\n        i0 = colsol[j2];\n      }\n\n      // (re-)assign i to j1, possibly de-assigning an i0.\n      rowsol[i] = j1;\n      colsol[j1] = i;\n\n      if (i0 > -1)\n        if (umin < usubmin)\n          // minimum column j1 assigned earlier.\n          // put in current k, and go back to that k.\n          // continue augmenting path i - j1 with i0.\n          free[--k] = i0;\n        else\n          // no further augmenting reduction possible.\n          // store i0 in list of free rows for next phase.\n          free[numfree++] = i0;\n    }\n  } while (loopcnt < 2); // repeat once.\n\n  // AUGMENT SOLUTION for each free row.\n  for (f = 0; f < numfree; f++) {\n    freerow = free[f]; // start row of augmenting path.\n\n    // Dijkstra shortest path algorithm.\n    // runs until unassigned column added to shortest path tree.\n    for (j = dim; j--;) {\n      d[j] = cost(freerow, j) - v[j];\n      pred[j] = freerow;\n      collist[j] = j; // init column list.\n    }\n\n    low = 0; // columns in 0..low-1 are ready, now none.\n    up = 0; // columns in low..up-1 are to be scanned for current minimum, now none.\n    // columns in up..dim-1 are to be considered later to find new minimum,\n    // at this stage the list simply contains all columns\n    unassignedfound = false;\n    do {\n      if (up === low) {\n        // no more columns to be scanned for current minimum.\n        last = low - 1;\n\n        // scan columns for up..dim-1 to find all indices for which new minimum occurs.\n        // store these indices between low..up-1 (increasing up).\n        min = d[collist[up++]];\n        for (k = up; k < dim; k++) {\n          j = collist[k];\n          h = d[j];\n          if (h <= min) {\n            if (h < min) {\n              // new minimum.\n              up = low; // restart list at index low.\n              min = h;\n            }\n            // new index with same minimum, put on undex up, and extend list.\n            collist[k] = collist[up];\n            collist[up++] = j;\n          }\n        }\n        // check if any of the minimum columns happens to be unassigned.\n        // if so, we have an augmenting path right away.\n        for (k = low; k < up; k++)\n          if (colsol[collist[k]] < 0) {\n            endofpath = collist[k];\n            unassignedfound = true;\n            break;\n          }\n      }\n\n      if (!unassignedfound) {\n        // update 'distances' between freerow and all unscanned columns, via next scanned column.\n        j1 = collist[low];\n        low++;\n        i = colsol[j1];\n        h = cost(i, j1) - v[j1] - min;\n\n        for (k = up; k < dim; k++) {\n          j = collist[k];\n          v2 = cost(i, j) - v[j] - h;\n          if (v2 < d[j]) {\n            pred[j] = i;\n            if (v2 === min)\n              if (colsol[j] < 0) {\n                // new column found at same minimum value\n                // if unassigned, shortest augmenting path is complete.\n                endofpath = j;\n                unassignedfound = true;\n                break;\n              } else {\n                // else add to list to be scanned right away.\n                collist[k] = collist[up];\n                collist[up++] = j;\n              }\n            d[j] = v2;\n          }\n        }\n      }\n    } while (!unassignedfound);\n\n    // update column prices.\n    for (k = last + 1; k--;) {\n      j1 = collist[k];\n      v[j1] = v[j1] + d[j1] - min;\n    }\n\n    // reset row and column assignments along the alternating path.\n    do {\n      i = pred[endofpath];\n      colsol[endofpath] = i;\n      j1 = endofpath;\n      endofpath = rowsol[i];\n      rowsol[i] = j1;\n    } while (i !== freerow);\n  }\n\n  // calculate optimal cost.\n  let lapcost = 0;\n  for (i = dim; i--;) {\n    j = rowsol[i];\n    u[i] = cost(i, j) - v[j];\n    lapcost = lapcost + cost(i, j);\n  }\n\n  return {\n    cost: lapcost,\n    row: rowsol,\n    col: colsol,\n    u: u,\n    v: v\n  };\n}\n","import { PlaneAssignment, Formation, Plane, Slot } from \"./interfaces\"\nimport lapwrapper from \"./lapwrapper\"\nimport * as d3 from \"d3\"\n\nconst slotPlane = (\n  plane: Plane,\n  formation: Formation,\n  formationSlotIds: number[]\n) => {\n  const score = (formationSlotId: number, planeSlotId: number) => {\n    const slot = formation.slots[formationSlotId]\n    const { reverseBuildOrder } = slot\n    const { jr } = plane.slots[planeSlotId]\n\n    const slotJr = slot.offset.plus(slot.position).y\n\n    return Math.abs(jr) * reverseBuildOrder * 100 - slotJr * jr\n  }\n  return lapwrapper(formationSlotIds, d3.range(plane.filledSlots), score).map(\n    ([formationSlotId, planeSlotId]) => ({ formationSlotId, planeSlotId })\n  )\n}\n\nexport default function slotify(\n  formation: Formation,\n  planes: Plane[],\n  planeAssignments: PlaneAssignment[]\n): Slot[] {\n  return planes.flatMap((plane, idx) => {\n    const formationSlotIds = planeAssignments\n      .filter(({ planeId }) => planeId === idx)\n      .map(({ formationSlotId }) => formationSlotId)\n    return slotPlane(plane, formation, formationSlotIds).map(p => ({\n      planeId: idx,\n      ...p\n    }))\n  })\n}\n","import { Formation, Plane, Slot } from \"./interfaces\"\nimport planeify from \"./planeify\"\nimport slotify from \"./slotify\"\n\nexport default (formation: Formation, planes: Plane[]): Slot[] => {\n  return slotify(formation, planes, planeify(formation, planes))\n}\n","import Polar from \"../../geometry/Polar\"\n\nimport { range } from \"d3\"\nimport { FormationSlot, ComponentSlot } from \"../interfaces\"\n\nexport default abstract class Component {\n  slots: number\n  slotNumOffset: number\n\n  constructor(slots: number, slotNumOffset: number) {\n    if (slots < 0) {\n      throw new Error(`slots should be non-negative, was ${slots}`)\n    }\n    this.slots = slots\n    this.slotNumOffset = slotNumOffset\n  }\n\n  checkSlot(slot: number) {\n    if (slot < 0 || slot >= this.slots)\n      throw new Error(`slot should be in [0, ${this.slots}), was ${slot}`)\n  }\n\n  slotData(slot: number): ComponentSlot {\n    this.checkSlot(slot)\n\n    return {\n      offset: this.position(),\n      position: this.slotPosition(slot),\n      dockAngle: this.dockAngle(),\n      buildOrder: this.buildOrder(slot) + this.waiting()\n    }\n  }\n\n  allSlots(): ComponentSlot[] {\n    return range(this.slots).map(slot => this.slotData(slot))\n  }\n\n  //returns position of slot *relative to position of component*\n  slotPosition(s: number, offset = false) {\n    this.checkSlot(s)\n    const pos = new Polar(\n      this.radius(),\n      this.rotation() - 2 * s * this.dockAngle()\n    )\n    return offset ? pos.plus(this.position()) : pos\n  }\n\n  //returns position of left hand of slot *relative to center of formation*\n  dockPosition(s: number) {\n    this.checkSlot(s)\n    return this.slotPosition(s)\n      .rotate(-this.dockAngle())\n      .plus(this.position())\n  }\n\n  //how long this component is waiting before building\n  waiting(): number {\n    return Math.max(\n      ...this.parents().map(\n        parent => parent.waiting() + parent.maxBuildOrder()\n      ),\n      0\n    )\n  }\n\n  // return build order for last slot to build\n  abstract maxBuildOrder(): number\n\n  //should return build order for slot\n  abstract buildOrder(slot: number): number\n\n  //returns radius of this component\n  abstract radius(): number\n\n  //returns center of this component\n  abstract position(): Polar\n\n  //returns rotation in theta of where to place first slot\n  abstract rotation(): number\n\n  //returns angle between slot position and dock position, i.e. half of wingspan angle\n  abstract dockAngle(): number\n\n  //components this component is docked\n  abstract parents(): Component[]\n}\n","import { PI, TAU } from \"../../constants\"\nimport Component from \"./Component\"\nimport Polar from \"../../geometry/Polar\"\n\ninterface Dock {\n  c: Component\n  s: number\n}\n\nexport type PRRD = {\n  position: Polar;\n  radius: number;\n  rotation: number;\n  dockAngle: number;\n}\n\nexport default class Round extends Component {\n  left: Dock\n  right: Dock\n  firstRun: boolean\n  private _prrd: PRRD | undefined\n  /*\n  left and right are left hand and right hand docks. \n  Should be an with properties\n    - c: component\n    - s: slot index\n  */\n  constructor(slots: number, slotNumOffset: number, left: Dock, right: Dock) {\n    super(slots, slotNumOffset)\n    this.left = left\n    this.right = right\n    this.firstRun = true\n  }\n\n  parents() {\n    return Array.from(new Set([this.left.c, this.right.c]))\n  }\n\n  get prrd() {\n    if (!this._prrd) {\n      this._prrd = Round._positionRadiusRotationDockAngle(\n        this.left.c.dockPosition(this.left.s),\n        this.right.c.dockPosition(this.right.s),\n        this.slots\n      )\n    }\n    return this._prrd\n  }\n\n  //computes the centroid position\n  //component radius, and component rotation\n  //position, radius, rotation, dockangle\n  /*\n  leftDockPosition - where component's left hand dock is\n  rightDockPosition - where component's right hand dock is\n  slots - number of slots in this component\n  // parentCentroid - centroid of parent component, or center of formation. Used to pick the orien\n  */\n  static _positionRadiusRotationDockAngle(\n    leftDockPosition: Polar,\n    rightDockPosition: Polar,\n    slots: number\n  ): PRRD {\n    const dockDistance = leftDockPosition.distanceFrom(rightDockPosition)\n    const { radius, theta } = Round.__computeRadiusTheta(slots, dockDistance)\n\n    const angleDelta = leftDockPosition.angleTo(rightDockPosition)\n    const position = leftDockPosition.plus(\n      new Polar(radius, angleDelta - (PI - theta) / 2)\n    )\n\n    //the rotation is where the first slot (docking w/ right hand) goes\n    // TAU - theta is the whole arc angle, and their position is 1/(2*slots) around\n    const dockAngle = (TAU - theta) / (2 * slots)\n    const rotation = position.angleTo(rightDockPosition) - dockAngle\n\n    return { position, radius, rotation, dockAngle }\n  }\n\n  position() {\n    return this.prrd.position\n  }\n\n  radius() {\n    return this.prrd.radius\n  }\n\n  rotation() {\n    return this.prrd.rotation\n  }\n\n  dockAngle() {\n    return this.prrd.dockAngle\n  }\n\n  maxBuildOrder() {\n    return Math.ceil(this.slots / 2)\n  }\n\n  buildOrder(slot: number) {\n    this.checkSlot(slot)\n\n    //build from the ends\n    return Math.min(slot + 1, this.slots - slot)\n  }\n\n  // computes radius and angle of cutoff for a circle with the side cut off\n  // with length of the remaining curve part = s\n  // and length of flat bit = d\n  // I think it's O(-log(eps))\n  static __computeRadiusTheta(\n    s: number,\n    d: number,\n    eps = Math.sqrt(Number.EPSILON)\n  ) {\n    if (d < 0 || d > s) {\n      console.error(`d: ${d}, s: ${s}`)\n      throw new Error(\"d must be in [0, s]\")\n    }\n    var iters = 0\n    //try picking theta between lower and upper\n    function iter(lower = 0, upper = PI): number {\n      if (iters >= 100) {\n        throw new Error(\"didn't converge\")\n      }\n      iters = iters + 1\n      const mid = (upper + lower) / 2\n      // if ((upper - lower) < eps) {\n      //   return mid\n      // }\n\n      //candidate theta = mid\n      //compute radius from theta\n      const r = d / (2 * Math.sin(mid / 2))\n      //compute s from radius, theta\n      const ss = r * (TAU - mid)\n\n      if (Math.abs(ss - s) < eps) {\n        return mid\n      }\n\n      //if computed s is too big, try a bigger theta, else try smaller\n      return ss > s ? iter(mid, upper) : iter(lower, mid)\n    }\n    //iter returns theta, compute radius\n    const theta = iter()\n    return {\n      radius: s / (TAU - iter()),\n      theta: theta\n    }\n  }\n}\n","import Component from \"./Component\"\nimport Round, { PRRD } from \"./Round\"\nimport Polar from \"../../geometry/Polar\"\n\ninterface Dock {\n  c: Component\n  s: number\n}\n\nexport default class Whacker extends Component {\n  dock: Dock\n  hand: string\n  private _prrd: PRRD | undefined\n\n  /*\n  slots - \n  dock - { component, slot } this whacker is docked on\n  hand - docked with 'left' or 'right'\n \n  modeled as part of a pod (Round docked on one person) with slots * 2 + 1 slots\n  */\n  constructor(slots: number, slotNumOffset: number, dock: Dock, hand: string) {\n    super(slots, slotNumOffset)\n    this.dock = dock\n\n    if (hand !== \"left\" && hand !== \"right\")\n      throw new Error(\"Hand should be 'left' or 'right'\")\n    this.hand = hand\n  }\n\n  parents() {\n    return [this.dock.c]\n  }\n\n  //left hand dock position of the imaginary pod\n  _left() {\n    const { c, s } = this.dock\n    return this.hand === \"left\"\n      ? c.dockPosition(s)\n      : c\n          .slotPosition(s)\n          .rotate(-3 * c.dockAngle()) //move 1.5 slots to the left\n          .plus(c.position())\n  }\n\n  //right hand dock position of the imaginary pod\n  _right() {\n    const { c, s } = this.dock\n    return this.hand === \"left\"\n      ? c\n          .slotPosition(s)\n          .rotate(c.dockAngle()) //move half a slot to the right\n          .plus(c.position())\n      : c.dockPosition(s)\n  }\n\n  get prrd() {\n    if (!this._prrd) {\n      const psuedoSlots = this.slots * 2 + 1\n\n      this._prrd = Round._positionRadiusRotationDockAngle(\n        this._left(),\n        this._right(),\n        psuedoSlots\n      )\n\n      if (this.hand === \"left\") {\n        const invisibleSlots = psuedoSlots - this.slots\n        const { rotation, dockAngle } = this._prrd\n        const fixedRotation = Polar.unspin(\n          rotation - invisibleSlots * 2 * dockAngle\n        ) //rotate two slots to the right\n        this._prrd.rotation = fixedRotation\n      }\n    }\n    return this._prrd\n  }\n\n  maxBuildOrder() {\n    return this.slots\n  }\n\n  buildOrder(slot: number) {\n    this.checkSlot(slot)\n    return this.hand === \"left\" ? this.slots - slot : slot + 1\n  }\n\n  position() {\n    return this.prrd.position\n  }\n\n  radius() {\n    return this.prrd.radius\n  }\n\n  rotation() {\n    return this.prrd.rotation\n  }\n\n  dockAngle() {\n    return this.prrd.dockAngle\n  }\n}\n","import Polar from \"../../geometry/Polar\"\nimport Component from \"./Component\"\nimport { PI, TAU } from \"../../constants\"\n\nexport default class Base extends Component {\n  _rotation: number\n  constructor(slots: number, rotation = (3 * PI) / 2) {\n    super(slots, 0)\n    this._rotation = rotation\n  }\n\n  //angle to the first slot\n  rotation() {\n    return this._rotation\n  }\n\n  position() {\n    return new Polar(0, 0)\n  }\n\n  // circumference = 2 PI r\n  // circumference = # slots\n  radius() {\n    return this.slots / TAU\n  }\n\n  //angle between slot position and dock position\n  dockAngle() {\n    return TAU / (this.slots * 2)\n  }\n\n  maxBuildOrder(): number {\n    return 1\n  }\n\n  buildOrder(slot: number) {\n    this.checkSlot(slot)\n    return 1\n  }\n\n  parents() {\n    return []\n  }\n}\n","import { BaseSlot, SlotCollection, NumDict } from \"./interfaces\"\nimport arrayToDict from \"../util/arrayToDict\"\n\nexport default abstract class AbstractSlotCollection<S extends BaseSlot>\n  implements SlotCollection<S> {\n  private _slots?: S[]\n\n  protected abstract computeSlots(): S[]\n\n  get slots(): S[] {\n    if (!this._slots) {\n      this._slots = this.computeSlots()\n    }\n\n    return this._slots\n  }\n}\n","import Round from \"./components/Round\"\nimport Whacker from \"./components/Whacker\"\nimport Base from \"./components/Base\"\nimport Component from \"./components/Component\"\nimport AbstractSlotCollection from \"./AbstractSlotCollection\"\nimport { FormationSlot, Formation } from \"./interfaces\"\n\ntype Ring = Component[]\ntype Dock = { c: Component; s: number }\n\n/**\n * computes the number of slots in a ring\n * @param {Number} ring index of ring,\n *         ring 0 = base,\n *         ring 1 = 1st pods\n *         ring 2 = 2nd pods\n *         ring 3 = if baseSize > 4, bridges, otherwise just pods on out\n *         ring 4 = if baseSize > 4, then pods on bridges in ring 3, otherwise just pods on podLines\n *         ring 5... pod lines on out\n */\nconst slotsInRing = (baseSize: number, ring: number): number => {\n  const podLines = Math.round(baseSize / 2)\n  const bridges = podLines > 2\n  if (ring === 0) {\n    return baseSize\n  }\n  if (ring === 1) {\n    return baseSize + podLines * 5\n  }\n  if (ring === 2) {\n    return baseSize + podLines * 10\n  }\n  if (ring === 3) {\n    return (\n      slotsInRing(baseSize, ring - 1) + (bridges ? 3 * podLines : 5 * podLines)\n    )\n  }\n  if (ring === 4) {\n    return (\n      slotsInRing(baseSize, ring - 1) + (bridges ? 5 * podLines : 5 * baseSize)\n    )\n  }\n  return (\n    slotsInRing(baseSize, 4) +\n    (ring - 4) * (bridges ? 5 * podLines : 5 * baseSize)\n  )\n}\n\n/**\n * gets dock positions for next ring given currently filled rings\n * @param rings an array of rings, 0th starting at base and going out\n */\nconst nextDockPositions = (\n  baseSize: number,\n  rings: Ring[]\n): { left: Dock; right: Dock }[] => {\n  if (rings.length > 10) {\n    throw new Error(\"somethings fucky\")\n  }\n  const bridges = baseSize !== 4\n\n  if (rings.length === 1) {\n    const base = rings[0][0]\n\n    return Array.from(new Array(baseSize / 2).keys())\n      .map(s => s * 2)\n      .map(slot => ({\n        left: { c: base, s: slot },\n        right: { c: base, s: (slot + baseSize - 1) % baseSize }\n      }))\n  }\n  if (\n    !bridges ||\n    rings.length === 2 ||\n    rings.length === 4 ||\n    rings.length >= 6\n  ) {\n    // if we're not using bridges\n    // or last ring (1) is 1st pods (and we need 2nd pods)\n    // or last ring (3) is bridges (and we need 2nd pods on those bridges)\n    // or we're way out (last ring >= 5)\n    // then we want pods on everything in the last ring\n    return rings[rings.length - 1].map(component => {\n      const isPod = component.slots === 5\n      return {\n        left: { c: component, s: 1 + (isPod ? 1 : 0) },\n        right: { c: component, s: 0 + (isPod ? 1 : 0) }\n      }\n    })\n  }\n  if (bridges && rings.length === 3) {\n    // ring 3 is bridges if there are bridges\n    const firstPods = rings[1]\n    const numBridges = firstPods.length\n    return Array.from(new Array(numBridges).keys()).map(bridgeNum => ({\n      left: { c: firstPods[(bridgeNum + 1) % numBridges], s: 0 },\n      right: { c: firstPods[bridgeNum], s: 3 }\n    }))\n  }\n  if (bridges && rings.length === 5) {\n    // if bridges, ring 5 is 2nd pods on bridges\n    const secondPods = rings[2]\n    const bridgeSecondPods = rings[4]\n    return secondPods\n      .flatMap((secondPod, idx) => [secondPod, bridgeSecondPods[idx]])\n      .map(component => {\n        return {\n          left: { c: component, s: component.slots === 5 ? 2 : 1 }, //5 -> pod, !5 (3) -> bridge\n          right: { c: component, s: component.slots === 5 ? 1 : 0 }\n        }\n      })\n  }\n  throw new Error(\"mmm\")\n}\n\n/**\n * this takes an array of rings starting with at least the Base, and\n * adds rings until all slots are included\n * @param {*} rings array of rings. (a ring is an array of components)\n */\nconst addRings = (slots: number, baseSize: number, rings: Ring[]): Ring[] => {\n  const completeRings = rings.length - 1\n\n  //compute slots in next ring\n  const nextRingSlots =\n    Math.min(slots, slotsInRing(baseSize, completeRings + 1)) -\n    slotsInRing(baseSize, completeRings)\n\n  if (nextRingSlots <= 0) return rings //we're done\n\n  const dockPositions = nextDockPositions(baseSize, rings)\n\n  // here a 'group' is either a pod, or, if there are less than 5 slots, two whackers\n  const slotGroups = dockPositions.length\n\n  const slotsPerGroup = Math.floor(nextRingSlots / slotGroups)\n  const groupsWithExtraSlot = nextRingSlots % slotGroups\n\n  const nextRing: Ring = dockPositions.flatMap(\n    ({ left, right }, groupNum): Ring => {\n      //slots in this group\n      const slotsToFill =\n        slotsPerGroup + (groupNum < groupsWithExtraSlot ? 1 : 0)\n      const isPod = left.c === right.c //left and right docking on same component is a pod, else bridge\n      const totalSlotsInGroup = isPod ? 5 : 3\n\n      const priorSlots =\n        slotsInRing(baseSize, completeRings) + //number of slots in prior rings\n        slotsPerGroup * groupNum + //number of slots in prior groups in this ring\n        Math.min(groupsWithExtraSlot, groupNum) //an extra slot per prior group, up to groupsWithExtraSlot\n\n      if (slotsToFill === totalSlotsInGroup) {\n        //if we have to fill the whole group, it's a pod\n        return [new Round(totalSlotsInGroup, priorSlots, left, right)]\n      } else {\n        //whackers\n        const leftHandSlots = Math.floor(slotsToFill / 2)\n        const rightHandSlots = leftHandSlots + (slotsToFill % 2) //if odd number, right hand whacker gets the extra\n        const whackers = []\n        if (leftHandSlots > 0) {\n          whackers.push(\n            new Whacker(\n              leftHandSlots,\n              priorSlots + rightHandSlots,\n              left,\n              \"left\"\n            )\n          )\n        }\n        if (rightHandSlots > 0) {\n          whackers.push(\n            new Whacker(rightHandSlots, priorSlots, right, \"right\")\n          )\n        }\n        return whackers\n      }\n    }\n  )\n  //recurse, add more rings to this prior plus this ring\n  return addRings(slots, baseSize, [...rings, nextRing])\n}\n\nclass FormationImpl extends AbstractSlotCollection<FormationSlot>\n  implements Formation {\n  components: Component[]\n  constructor(components: Component[]) {\n    super()\n    this.components = components\n  }\n\n  protected computeSlots(): FormationSlot[] {\n    const reverseBuildOrder = this.reverseBuildOrder()\n    return this.components\n      .flatMap(c => c.allSlots())\n      .map((s, idx) => ({ ...s, reverseBuildOrder: reverseBuildOrder[idx] }))\n  }\n\n  get baseIds(): number[] {\n    return this.components\n      .find(c => c instanceof Base)!\n      .allSlots()\n      .map((s, idx) => idx)\n  }\n\n  get radius(): number {\n    const slotRadi = this.slots.map(\n      ({ position, offset }) => position.plus(offset).radius\n    )\n    return Math.max(...slotRadi)\n  }\n\n  reverseBuildOrder() {\n    const parentToChildren = new Map(\n      this.components.map(component => [component, [] as Component[]])\n    )\n\n    this.components\n      .flatMap(child => child.parents().map(parent => ({ parent, child }))) //get all parent child pairs (many to many)\n      .forEach(({ parent, child }) =>\n        parentToChildren.get(parent)!.push(child)\n      )\n\n    const componentToWaiting = new Map<Component, number>()\n\n    const waiting = (component: Component): number => {\n      if (!componentToWaiting.has(component)) {\n        const children = parentToChildren.get(component)!\n        const numWaiting = Math.max(\n          ...children.map(child => waiting(child)! + child.maxBuildOrder()),\n          0\n        )\n\n        componentToWaiting.set(component, numWaiting)\n      }\n      return componentToWaiting.get(component)!\n    }\n    waiting(this.components[0])\n    return this.components.flatMap(c => {\n      return Array.from(new Array(c.slots).keys()).map(\n        s => waiting(c) + c.maxBuildOrder() - c.buildOrder(s)\n      )\n    })\n  }\n}\n\n/**\n * Builds a formation using the following rules until we run out of slots\n *    1) Start with the base\n *    2) Add first pods on every other base slot, starting with the slot going up jump run moving left\n *    3) Add second pods on first pods\n *    4) If base size > 4, build bridges between frist pods\n *    5) If there are bridges, build 2nd pods on bridges\n *    6) Build pods on each pod line on out to infinity!\n *\n * If there are not enough slots to complete a ring of pods/bridges, then build whackers\n *\n * @param {Number} slots slots in this formation\n * @param {Number} baseSize\n * @returns an array of Components\n */\nexport default function buildFormation(\n  slots: number,\n  baseSize: number\n): Formation {\n  return new FormationImpl(\n    addRings(slots, baseSize, [[new Base(baseSize)]]).flat()\n  )\n}\n","import { createSelector } from \"reselect\"\nimport {\n  PlaneType,\n  Slotting,\n  FormationConfigState,\n  PlaneState\n} from \"../store/types\"\nimport { AppState } from \"../store/reducer\"\n\nexport const getFormationConfig = (state: AppState): FormationConfigState =>\n  state.formationConfig\nexport const getPlanesConfig = (state: AppState): PlaneState[] =>\n  state.planesConfig\n\nexport type SlotOptions = {\n  slots: number;\n  min: number;\n  max: number;\n}\n\nconst slotOptions = (\n  formationConfig: { baseSize: number; slots: number },\n  planesConfig: PlaneState[]\n): SlotOptions => {\n  const { min, max } = planesConfig\n    .filter(({ type }) => type !== PlaneType.NONE)\n    .map(({ slotting, slots }) => ({\n      //compute min/max slots on each plane\n      planeMin: slotting === Slotting.FILL ? slots : 0,\n      planeMax: slots\n    }))\n    .reduce(\n      ({ min, max }, { planeMin, planeMax }) => ({\n        //add min/max slots for all planes\n        min: min + planeMin,\n        max: max + planeMax\n      }),\n      { min: 0, max: 0 }\n    )\n\n  const fixedMin = Math.max(min, formationConfig.baseSize)\n\n  return {\n    min: fixedMin,\n    max,\n    slots: Math.max(Math.min(formationConfig.slots, max), fixedMin)\n  }\n}\n\n/**\n * computes min, max, and current number of slots based on plane and formation config\n *\n * if current slots is outside of [min, max], it is set to min or max\n */\nexport default createSelector(\n  [getFormationConfig, getPlanesConfig],\n  slotOptions\n)\n","import AbstractSlotCollection from \"./AbstractSlotCollection\"\nimport { PlaneSlot, Plane } from \"./interfaces\"\nimport PlanePosition from \"./PlanePosition\"\nimport { TAU } from \"../constants\"\nimport * as d3 from \"d3\"\nimport { PlaneType } from \"../store/types\"\n\nabstract class AbstractPlane extends AbstractSlotCollection<PlaneSlot>\n  implements Plane {\n  position: PlanePosition\n  filledSlots: number\n\n  constructor(position: PlanePosition, filledSlots: number) {\n    super()\n    this.position = position\n    this.filledSlots = filledSlots\n  }\n\n  get theta() {\n    switch (this.position) {\n      case PlanePosition.LEAD:\n        return (3 * TAU) / 12\n      case PlanePosition.LT:\n        return (7 * TAU) / 12\n      case PlanePosition.RT:\n        return (11 * TAU) / 12\n    }\n  }\n}\n\n/**\n *     x x\n *     x x\n *     x x\n *     x x\n *     x x\n *  x  x x\n *  x\n *  x x x\n *  x x x\n *  x x\n *  x\n *  x\n */\nexport class Otter extends AbstractPlane {\n  /**\n   * jrOffset determines which slot is considered 0 up or down jump run\n   * 3 is the 1st diver closet do the pilot just inside the door\n   * increase to the 'centeral' slot closer to the tail, decrease to move to cockpit\n   */\n  private jrOffset = 1\n  protected computeSlots(): PlaneSlot[] {\n    const l = 6\n    const floaters = d3\n      .range(7)\n      .map(y => ({ x: -2, y: l - 0.5 - y, jr: -y + this.jrOffset + 8 }))\n    const inDoor = d3\n      .range(3)\n      .map(y => ({ x: -1, y: l - 3 - y, jr: -y + this.jrOffset + 1 }))\n    const inDoor2 = d3\n      .range(2)\n      .map(y => ({ x: 0, y: l - 3.5 - y, jr: -y + this.jrOffset + -2 }))\n    const divers = d3\n      .range(6)\n      .flatMap(y => [\n        { x: -0.5, y: -0.5 - y, jr: -2 * y + this.jrOffset - 5 },\n        { x: 0.5, y: -0.5 - y, jr: -2 * y + this.jrOffset - 4 }\n      ])\n    return [...floaters, ...inDoor, ...inDoor2, ...divers]\n  }\n}\n\nexport const planeFactory = (\n  position: PlanePosition,\n  filledSlots: number,\n  type: PlaneType\n): Plane => {\n  switch (type) {\n    case PlaneType.OTTER:\n      return new Otter(position, filledSlots)\n    case PlaneType.SKYVAN:\n      throw new Error(\"SKYVAN not implemented\")\n    case PlaneType.NONE:\n      throw new Error(\"PLaneType is NONE\")\n  }\n}\n","import { PlaneState, PlaneType, Slotting } from \"../store/types\"\nimport { Plane } from \"./interfaces\"\nimport PlanePosition from \"./PlanePosition\"\nimport { planeFactory } from \"./planes\"\n\ntype FilledPlane = {\n  position: PlanePosition;\n  filledSlots: number;\n}\n\nconst countFilledSlots = (filledPlanes: FilledPlane[]) =>\n  filledPlanes.reduce((s, { filledSlots }) => s + filledSlots, 0)\n\n/**\n *\n * @param unfilledPlanes array of objects representing planes with slots left.\n *                       should have properties plane (lead, lt, rt), slots (total slots in plane)\n * @param slotsRemaining slots to put in unfilledPlanes\n * @param baseSize if unfilledPlanes includes lead plane, at least `baseSize` should go in it\n * @param filledPlanes array of planes already full, or partially full if slotsRemaining = 0\n */\nconst slotUnfilledPlanes = (\n  unfilledPlanes: PlaneState[],\n  slotsRemaining: number,\n  baseSize: number,\n  filledPlanes: FilledPlane[]\n): FilledPlane[] => {\n  if (unfilledPlanes.length === 0) {\n    return filledPlanes\n  }\n\n  const slotsPerPlane = slotsRemaining / unfilledPlanes.length\n\n  // if spreading remaing slots evently doesn't put enough in the lead plane for the base, fill that now\n  const lead = unfilledPlanes.find(\n    ({ position }) => position === PlanePosition.LEAD\n  )\n  if (lead && baseSize > slotsPerPlane) {\n    return slotUnfilledPlanes(\n      unfilledPlanes.filter(({ position }) => position !== PlanePosition.LEAD),\n      slotsRemaining - baseSize,\n      baseSize,\n      [{ position: PlanePosition.LEAD, filledSlots: baseSize }, ...filledPlanes]\n    )\n  }\n\n  //get planes with fewer total slots than slotsPerPlane and fill em up\n  const littlePlanes = unfilledPlanes\n    .filter(({ slots }) => slots < slotsPerPlane)\n    .map(({ position, slots }) => ({ position, filledSlots: slots }))\n\n  if (littlePlanes.length) {\n    const littlePlaneLabels = littlePlanes.map(({ position }) => position)\n    return slotUnfilledPlanes(\n      unfilledPlanes.filter(\n        ({ position }) => !littlePlaneLabels.includes(position)\n      ),\n      slotsRemaining - countFilledSlots(littlePlanes),\n      baseSize,\n      [...filledPlanes, ...littlePlanes]\n    )\n  }\n\n  // if we've gotten this far, there is room for at least slotsPerPlane on each unfilledPlane\n  const minSlotsPerPlane = Math.floor(slotsPerPlane)\n  const extras = slotsRemaining % minSlotsPerPlane\n\n  // if the lead plane is still in the mix, then always put one less on that plane\n  if (extras > 0 && lead) {\n    const filledLead = {\n      position: PlanePosition.LEAD,\n      filledSlots: minSlotsPerPlane\n    }\n    return slotUnfilledPlanes(\n      unfilledPlanes.filter(({ position }) => position !== PlanePosition.LEAD),\n      slotsRemaining - minSlotsPerPlane,\n      baseSize,\n      [filledLead, ...filledPlanes]\n    )\n  }\n\n  //okay now fill the rest. the first `extras` planes will get an extra\n  const remainingFilled = unfilledPlanes.map(({ position }, i) => ({\n    position,\n    filledSlots: minSlotsPerPlane + (extras > i ? 1 : 0)\n  }))\n\n  //phew\n  return [...filledPlanes, ...remainingFilled]\n}\n\n/**\n *\n * @param baseSize\n * @param planesConfig\n * @param slotOptions\n */\nconst filledPlanes = (\n  slots: number,\n  baseSize: number,\n  planesConfig: PlaneState[]\n): FilledPlane[] => {\n  const filledPlanes = planesConfig\n    .filter(\n      ({ type, slotting }) =>\n        type !== PlaneType.NONE && slotting === Slotting.FILL\n    )\n    .map(({ position, slots }) => ({ position, filledSlots: slots }))\n\n  const unfilledPlanes = planesConfig.filter(\n    ({ type, slotting }) =>\n      type !== PlaneType.NONE && slotting !== Slotting.FILL\n  )\n\n  return slotUnfilledPlanes(\n    unfilledPlanes,\n    slots - countFilledSlots(filledPlanes),\n    baseSize,\n    filledPlanes\n  )\n}\n\nexport default (\n  slots: number,\n  baseSize: number,\n  planesConfig: PlaneState[]\n): Plane[] => {\n  const slotsMap = new Map(\n    filledPlanes(slots, baseSize, planesConfig).map(\n      ({ position, filledSlots }) => [position, filledSlots]\n    )\n  )\n\n  return planesConfig.map(({ position, type }) =>\n    planeFactory(position, slotsMap.get(position)!, type)\n  )\n}\n","import { createSelector } from \"reselect\"\nimport buildSlots from \"../formation/buildSlots\"\nimport buildFormation from \"../formation/buildFormation\"\nimport getSlotOptions from \"./getSlotOptions\"\nimport buildPlanes from \"../formation/buildPlanes\"\nimport { AppState } from \"../store/reducer\"\nimport { PlaneType } from \"../store/types\"\n\nexport { default as getSlotOptions } from \"./getSlotOptions\"\n\nconst getSlots = (state: AppState) => getSlotOptions(state).slots\nconst getBaseSize = (state: AppState): number => state.formationConfig.baseSize\nconst getFilteredPlanesConfig = (state: AppState) => {\n  return state.planesConfig.filter(({ type }) => type !== PlaneType.NONE)\n}\n\nexport const getFormation = createSelector(\n  [getSlots, getBaseSize],\n  buildFormation\n)\nexport const getPlanes = createSelector(\n  [getSlots, getBaseSize, getFilteredPlanesConfig],\n  buildPlanes\n)\nexport const getAllSlots = createSelector(\n  [getFormation, getPlanes],\n  buildSlots\n)\n","import { Formation, Plane, PlaneAssignment } from \"./interfaces\"\nimport PlanePosition from \"./PlanePosition\"\nimport Polar from \"../geometry/Polar\"\nimport { PI } from \"../constants\"\nimport approxeq from \"../util/approxeq\"\nimport lapwrapper from \"./lapwrapper\"\n\n/**\n * Puts people in planes\n * @param formation\n * @param planes lead assumed to be first\n */\nexport default function planeify(\n  formation: Formation,\n  planes: Plane[]\n): PlaneAssignment[] {\n  if (planes[0].position !== PlanePosition.LEAD) {\n    throw new Error(\"lead plane should be first\")\n  }\n\n  //slotted[planeId] = array of slot indexes for plane planeId\n  const slotted = planes.map(() => [] as number[])\n\n  // ### rule based slotting ###\n  // base in lead f\n\n  slotted[0].push(...formation.baseIds)\n\n  //todo add superfloat\n\n  // ### end rule based slotting ###\n\n  //using linear assignment problem formulation\n\n  const angleScore = (slotId: number, planeId: number) => {\n    const slot = formation.slots[slotId]\n    const plane = planes[planeId]\n    const slotPosition = slot.position.plus(slot.offset)\n    const diff = Polar.unspin(slotPosition.theta - plane.theta)\n\n    //penalize if component is on other side of jumprun from plane\n    //componentTheta is component angle rotated 90 right\n    // if > pi, right side of jump run. if < pi, left side of jump run\n    const componentTheta = Polar.unspin(slot.offset.theta - PI / 2)\n    const componentPosition =\n      approxeq(componentTheta, 0) || approxeq(componentTheta, PI)\n        ? PlanePosition.LEAD\n        : componentTheta > PI\n        ? PlanePosition.RT\n        : PlanePosition.LT\n\n    const penalty =\n      componentPosition === PlanePosition.LEAD ||\n      plane.position === PlanePosition.LEAD ||\n      componentPosition === plane.position\n        ? 0\n        : PI\n\n    return Math.min(diff, 2 * PI - diff) + penalty\n  }\n\n  //   const distScore = (slotId: number, planeId: number) => {\n  //     const slot = formation.allSlots[slotId]\n  //     const plane = planes[planeId]\n  //     return Math.abs(slot.position.plus(slot.offset).distanceFrom(new Polar(100, plane.theta)))\n  //   }\n\n  //get an array of formationSlotId that are not already in slotted\n  const unslotted = Array.from(formation.slots.keys()).filter(\n    formationSlotId => !slotted.flat().includes(formationSlotId)\n  )\n\n  // planeArray is an array of planeIds, repeated for the number of slots to fill in that plane\n  const planeArray = planes.flatMap((plane, planeId) => {\n    const remainigToFill = plane.filledSlots - slotted[planeId].length\n    return (Array(remainigToFill) as number[]).fill(planeId)\n  })\n\n  //takes a scoreFun that takes a slotId and planeId,\n  //and converts it to a function that takes i, j for i, j in [0, number of unslotted people)\n  //for use with lap()\n  const cost = (scoreFun: (slotId: number, planeId: number) => number) => {\n    if (planeArray.length !== unslotted.length) {\n      throw new Error(\"planeArray and unslotted have diff lenghts\")\n    }\n\n    //memoize scoreFun\n    const memo = new Map<string, number>()\n    return (i: number, j: number): number => {\n      const key = `${i}.${j}`\n      if (!memo.has(key)) {\n        const slotId = unslotted[i]\n        const planeId = planeArray[j]\n        memo.set(key, scoreFun(slotId, planeId))\n      }\n      return memo.get(key)!\n    }\n  }\n\n  const assignments = lapwrapper(unslotted, planeArray, angleScore)\n\n  assignments.forEach(([slotId, planeId]) => slotted[planeId].push(slotId))\n\n  return slotted.flatMap((slotIds, planeId) =>\n    slotIds.map(slotId => ({ formationSlotId: slotId, planeId }))\n  )\n}\n","import { connect } from \"react-redux\"\nimport FormationComponent from \"./FormationComponent\"\nimport { getFormation, getPlanes, getAllSlots } from \"../selectors\"\nimport { AppState } from \"../store/reducer\"\n\nconst mapStateToProps = (state: AppState) => ({\n  formation: getFormation(state),\n  planes: getPlanes(state),\n  slots: getAllSlots(state),\n  viewConfig: state.viewConfig\n})\n\nexport default connect(mapStateToProps)(FormationComponent)\n\n// console.log({debounceRender})\n\n// export default connect(\n//     mapStateToProps\n// )(debounceRender.debounceRender(FormationComponent, 100))\n","import React, { Dispatch } from \"react\"\nimport { connect } from \"react-redux\"\nimport { Dropdown, Icon } from \"semantic-ui-react\"\nimport { getSlotOptions } from \"../../selectors\"\nimport { formationSlots, baseSize } from \"../../store/actions\"\nimport { FormationConfigActionTypes } from \"../../store/types\"\nimport { AppState } from \"../../store/reducer\"\nimport { SlotOptions } from \"../../selectors/getSlotOptions\"\n\ntype Props = {\n  slotsOptions: SlotOptions;\n  baseSize: number;\n  onFormationSlotsSet: (slots: number) => void;\n  onBaseSizeSet: (size: number) => void;\n}\nconst Slots = (props: Props) => {\n  const {\n    slotsOptions: { min, max, slots },\n    baseSize,\n    onFormationSlotsSet,\n    onBaseSizeSet\n  } = props\n\n  const trigger = (\n    <span>\n      <Icon name=\"users\" /> <strong>Slots:</strong> {slots}\n    </span>\n  )\n\n  return (\n    <Dropdown trigger={trigger} pointing className=\"link item\">\n      <Dropdown.Menu>\n        <Dropdown.Item>\n          <span>{min} </span>\n          <input\n            type=\"range\"\n            value={slots}\n            min={min}\n            max={max}\n            onChange={e => onFormationSlotsSet(parseInt(e.target.value))}\n          />\n          <span> {max}</span>\n        </Dropdown.Item>\n        <Dropdown.Item>\n          <Dropdown\n            trigger={\n              <span>\n                <strong>Base Size</strong>: {baseSize}\n              </span>\n            }\n          >\n            <Dropdown.Menu>\n              {[4, 6, 8, 10].map(bs => (\n                <Dropdown.Item\n                  key={bs}\n                  onClick={() => onBaseSizeSet(bs)}\n                  active={baseSize === bs}\n                >\n                  {bs}\n                </Dropdown.Item>\n              ))}\n            </Dropdown.Menu>\n          </Dropdown>\n        </Dropdown.Item>\n      </Dropdown.Menu>\n    </Dropdown>\n  )\n}\n\nconst mapStateToProps = (state: AppState) => ({\n  slotsOptions: getSlotOptions(state),\n  baseSize: state.formationConfig.baseSize\n})\n\nconst mapDispatchToProps = (\n  dispatch: Dispatch<FormationConfigActionTypes>\n) => ({\n  onFormationSlotsSet: (slots: number) => dispatch(formationSlots(slots)),\n  onBaseSizeSet: (size: number) => dispatch(baseSize(size))\n})\n\nexport default connect(\n  mapStateToProps,\n  mapDispatchToProps\n)(Slots)\n","import {\n  SET_BASE_SIZE,\n  SET_FORMATION_SLOTS,\n  SET_FORMATION_TYPE,\n  SET_PLANE_SLOTTING,\n  SET_PLANE_TYPE,\n  SET_PLANE_SLOTS,\n  SET_COLOR_BY,\n  SET_NUMBER_BY,\n  ColorOption,\n  NumberOption,\n  PlaneType,\n  Slotting,\n  FormationType,\n  FormationConfigActionTypes,\n  PlanesConfigActionTypes,\n  ViewConfigActionTypes,\n  ShowOption,\n  SET_SHOW\n} from \"./types\"\nimport PlanePosition from \"../formation/PlanePosition\"\n\nexport const baseSize = (baseSize: number): FormationConfigActionTypes => ({\n  type: SET_BASE_SIZE,\n  baseSize\n})\n\nexport const formationSlots = (slots: number): FormationConfigActionTypes => ({\n  type: SET_FORMATION_SLOTS,\n  slots\n})\n\nexport const setFormationType = (\n  formationType: FormationType\n): FormationConfigActionTypes => ({\n  type: SET_FORMATION_TYPE,\n  formationType\n})\n\nexport const setPlaneSlotting = (\n  position: PlanePosition,\n  slotting: Slotting\n): PlanesConfigActionTypes => ({\n  type: SET_PLANE_SLOTTING,\n  position,\n  slotting\n})\n\nexport const setPlaneType = (\n  position: PlanePosition,\n  type: PlaneType\n): PlanesConfigActionTypes => ({\n  type: SET_PLANE_TYPE,\n  position,\n  planeType: type\n})\n\nexport const setPlaneSlots = (\n  position: PlanePosition,\n  slots: number\n): PlanesConfigActionTypes => ({\n  type: SET_PLANE_SLOTS,\n  position,\n  slots\n})\n\nexport const setColorBy = (colorBy: ColorOption): ViewConfigActionTypes => ({\n  type: SET_COLOR_BY,\n  colorBy\n})\n\nexport const setNumberBy = (numberBy: NumberOption): ViewConfigActionTypes => ({\n  type: SET_NUMBER_BY,\n  numberBy\n})\n\nexport const setShow = (show: ShowOption): ViewConfigActionTypes => ({\n  type: SET_SHOW,\n  show\n})\n","import React, { Dispatch } from \"react\"\nimport { connect } from \"react-redux\"\nimport { Dropdown, Icon } from \"semantic-ui-react\"\nimport {\n  PlaneType,\n  Slotting,\n  PlanesConfigActionTypes,\n  PlaneState\n} from \"../../store/types\"\nimport {\n  setPlaneType,\n  setPlaneSlots,\n  setPlaneSlotting\n} from \"../../store/actions\"\nimport PlanePosition from \"../../formation/PlanePosition\"\nimport { AppState } from \"../../store/reducer\"\n\ntype Setters = {\n  onPlaneTypeSet: (plane: PlanePosition, type: PlaneType) => void;\n  onPlaneSlotsSet: (plane: PlanePosition, slots: number) => void;\n  onPlaneSlottingSet: (plane: PlanePosition, slotting: Slotting) => void;\n}\n\ntype PlaneMenuProps = {\n  planeConfig: PlaneState;\n  setters: Setters;\n}\nconst PlaneMenu = (props: PlaneMenuProps) => {\n  const { planeConfig, setters } = props\n  const { position, label, slotting, type, slots } = planeConfig\n  const { onPlaneSlottingSet, onPlaneTypeSet, onPlaneSlotsSet } = setters\n  const trigger = (\n    <div>\n      <strong>{label}</strong>: {type}\n      {type !== PlaneType.NONE\n        ? `, ${slots} slots, ${\n            slotting === Slotting.FILL ? \"filled\" : \"slotted evenly\"\n          }`\n        : null}\n    </div>\n  )\n\n  const types =\n    position === PlanePosition.LEAD\n      ? [PlaneType.OTTER, PlaneType.SKYVAN]\n      : [PlaneType.OTTER, PlaneType.SKYVAN, PlaneType.NONE]\n\n  const { FILL, SPLIT } = Slotting\n  const slottingDescriptions = {\n    [FILL]: \"Fill plane\",\n    [SPLIT]: \"Split evenly\"\n  }\n  const slottings = [SPLIT, FILL]\n\n  return (\n    <Dropdown.Item>\n      <Dropdown trigger={trigger} fluid>\n        <Dropdown.Menu>\n          <Dropdown.Header>Type</Dropdown.Header>\n          {types.map(t => (\n            <Dropdown.Item\n              key={t}\n              onClick={() => onPlaneTypeSet(position, t)}\n              active={type === t}\n            >\n              {t}\n            </Dropdown.Item>\n          ))}\n          <Dropdown.Divider />\n          <Dropdown.Header>Slotting</Dropdown.Header>\n          {slottings.map(s => (\n            <Dropdown.Item\n              key={s}\n              onClick={() => onPlaneSlottingSet(position, s)}\n              active={slotting === s}\n            >\n              {slottingDescriptions[s]}\n            </Dropdown.Item>\n          ))}\n          <Dropdown.Divider />\n          <Dropdown.Header>Slots: {slots}</Dropdown.Header>\n          <Dropdown.Item>\n            <span>0 </span>\n            <input\n              type=\"range\"\n              value={slots}\n              min={0}\n              max={30}\n              onChange={e =>\n                onPlaneSlotsSet(position, parseInt(e.target.value))\n              }\n            />\n            <span> {30}</span>\n          </Dropdown.Item>\n        </Dropdown.Menu>\n      </Dropdown>\n    </Dropdown.Item>\n  )\n}\n\ntype PlanesProps = {\n  planesConfig: PlaneState[];\n  setters: Setters;\n}\nconst Planes = (props: PlanesProps) => {\n  const { planesConfig, setters } = props\n\n  const numPlanes = planesConfig.filter(({ type }) => type !== PlaneType.NONE)\n    .length\n\n  const trigger = (\n    <span>\n      <Icon name=\"plane\" /> <strong>Planes:</strong> {numPlanes}\n    </span>\n  )\n\n  return (\n    <Dropdown trigger={trigger} item>\n      <Dropdown.Menu>\n        {planesConfig.map(planeConfig => (\n          <PlaneMenu\n            key={planeConfig.position}\n            planeConfig={planeConfig}\n            setters={setters}\n          />\n        ))}\n      </Dropdown.Menu>\n    </Dropdown>\n  )\n}\n\nconst mapStateToProps = (state: AppState) => ({\n  planesConfig: state.planesConfig\n})\n\nconst mapDispatchToProps = (dispatch: Dispatch<PlanesConfigActionTypes>) => ({\n  setters: {\n    onPlaneTypeSet: (plane: PlanePosition, type: PlaneType) =>\n      dispatch(setPlaneType(plane, type)),\n    onPlaneSlotsSet: (plane: PlanePosition, slots: number) =>\n      dispatch(setPlaneSlots(plane, slots)),\n    onPlaneSlottingSet: (plane: PlanePosition, slotting: Slotting) =>\n      dispatch(setPlaneSlotting(plane, slotting))\n  }\n})\n\nexport default connect(\n  mapStateToProps,\n  mapDispatchToProps\n)(Planes)\n","import React, { Dispatch } from \"react\"\nimport { connect } from \"react-redux\"\nimport { Dropdown, Icon } from \"semantic-ui-react\"\nimport {\n  ColorOption,\n  NumberOption,\n  ShowOption,\n  ViewConfigState,\n  ViewConfigActionTypes\n} from \"../../store/types\"\nimport { setColorBy, setNumberBy, setShow } from \"../../store/actions\"\nimport { AppState } from \"../../store/reducer\"\n\ntype Props = {\n  viewConfig: ViewConfigState;\n  onSetColorBy: (opt: ColorOption) => void;\n  onSetNumberBy: (opt: NumberOption) => void;\n  onSetShow: (opt: ShowOption) => void;\n}\nconst View = (props: Props) => {\n  const { viewConfig, onSetColorBy, onSetNumberBy, onSetShow } = props\n\n  const trigger = (\n    <span>\n      <Icon name=\"eye\" /> <strong>View</strong>\n    </span>\n  )\n\n  const colorBys = [\n    { opt: ColorOption.DEFAULT, desc: \"Default\" },\n    { opt: ColorOption.PLANE, desc: \"Plane\" },\n    { opt: ColorOption.BUILD_ORDER, desc: \"Build Order\" }\n  ].map(({ opt, desc }) => (\n    <Dropdown.Item\n      key={opt}\n      onClick={() => onSetColorBy(opt)}\n      active={viewConfig.colorBy === opt}\n    >\n      {desc}\n    </Dropdown.Item>\n  ))\n\n  const numberBys = [\n    { opt: NumberOption.SLOT_NUM, desc: \"Slot Number\" },\n    { opt: NumberOption.BUILD_ORDER, desc: \"Build Order\" }\n  ].map(({ opt, desc }) => (\n    <Dropdown.Item\n      key={opt}\n      onClick={() => onSetNumberBy(opt)}\n      active={viewConfig.numberBy === opt}\n    >\n      {desc}\n    </Dropdown.Item>\n  ))\n\n  const show = [\n    { opt: ShowOption.FORMATION, desc: \"Formation\" },\n    { opt: ShowOption.PLANES, desc: \"Planes\" },\n    { opt: ShowOption.BOTH, desc: \"Formation & Planes\" }\n  ].map(({ opt, desc }) => (\n    <Dropdown.Item\n      key={opt}\n      onClick={() => onSetShow(opt)}\n      active={viewConfig.show === opt}\n    >\n      {desc}\n    </Dropdown.Item>\n  ))\n\n  return (\n    <Dropdown trigger={trigger} item>\n      <Dropdown.Menu>\n        <Dropdown.Header>Color by</Dropdown.Header>\n        {colorBys}\n        <Dropdown.Divider />\n        <Dropdown.Header>Number by</Dropdown.Header>\n        {numberBys}\n        <Dropdown.Divider />\n        <Dropdown.Header>Show</Dropdown.Header>\n        {show}\n      </Dropdown.Menu>\n    </Dropdown>\n  )\n}\n\nconst mapStateToProps = (state: AppState) => ({\n  viewConfig: state.viewConfig\n})\n\nconst mapDispatchToProps = (dispatch: Dispatch<ViewConfigActionTypes>) => ({\n  onSetColorBy: (colorBy: ColorOption) => dispatch(setColorBy(colorBy)),\n  onSetNumberBy: (numberBy: NumberOption) => dispatch(setNumberBy(numberBy)),\n  onSetShow: (show: ShowOption) => dispatch(setShow(show))\n})\n\nexport default connect(\n  mapStateToProps,\n  mapDispatchToProps\n)(View)\n","import React from \"react\"\nimport { Menu } from \"semantic-ui-react\"\nimport Slots from \"./config/Slots\"\nimport Planes from \"./config/Planes\"\nimport View from \"./config/View\"\n\nexport default () => (\n  <Menu size={\"mini\"} secondary>\n    <Slots />\n    <Planes />\n    <View />\n  </Menu>\n)\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import { combineReducers } from \"redux\"\nimport PlanePosition from \"../formation/PlanePosition\"\nimport {\n  PlaneState,\n  FormationConfigState,\n  ViewConfigState,\n  Slotting,\n  PlaneType,\n  FormationType,\n  ColorOption,\n  NumberOption,\n  SET_PLANE_SLOTTING,\n  SET_PLANE_SLOTS,\n  SET_PLANE_TYPE,\n  SET_FORMATION_SLOTS,\n  SET_FORMATION_TYPE,\n  SET_COLOR_BY,\n  SET_NUMBER_BY,\n  SET_BASE_SIZE,\n  FormationConfigActionTypes,\n  PlanesConfigActionTypes,\n  ViewConfigActionTypes,\n  SET_SHOW,\n  ShowOption\n} from \"./types\"\n\nconst { LEAD, LT, RT } = PlanePosition\n\nconst initialPlaneState: PlaneState[] = [\n  {\n    position: LEAD,\n    label: \"Lead\",\n    slotting: Slotting.SPLIT,\n    type: PlaneType.OTTER,\n    slots: 23\n  },\n  {\n    position: LT,\n    label: \"Left Trail\",\n    slotting: Slotting.SPLIT,\n    type: PlaneType.NONE,\n    slots: 23\n  },\n  {\n    position: RT,\n    label: \"Right Trail\",\n    slotting: Slotting.SPLIT,\n    type: PlaneType.OTTER,\n    slots: 23\n  }\n]\n\nconst planesConfig = (\n  state = initialPlaneState,\n  action: PlanesConfigActionTypes\n): PlaneState[] => {\n  const position = action.position\n  return state.map(p => {\n    if (p.position !== position) {\n      return p\n    }\n    switch (action.type) {\n      case SET_PLANE_SLOTTING:\n        return { ...p, slotting: action.slotting }\n      case SET_PLANE_SLOTS:\n        return { ...p, slots: action.slots }\n      case SET_PLANE_TYPE:\n        return { ...p, type: action.planeType }\n      default:\n        return p\n    }\n  })\n}\n\nconst formationConfig = (\n  state = { slots: 42, baseSize: 6, type: FormationType.HD },\n  action: FormationConfigActionTypes\n): FormationConfigState => {\n  switch (action.type) {\n    case SET_FORMATION_SLOTS:\n      return { ...state, slots: action.slots }\n    case SET_BASE_SIZE:\n      return { ...state, baseSize: action.baseSize }\n    case SET_FORMATION_TYPE:\n      return { ...state, type: action.formationType }\n    default:\n      return state\n  }\n}\n\nconst viewConfig = (\n  state = {\n    colorBy: ColorOption.PLANE,\n    numberBy: NumberOption.SLOT_NUM,\n    show: ShowOption.BOTH\n  },\n  action: ViewConfigActionTypes\n): ViewConfigState => {\n  switch (action.type) {\n    case SET_COLOR_BY:\n      return { ...state, colorBy: action.colorBy }\n    case SET_NUMBER_BY:\n      return { ...state, numberBy: action.numberBy }\n    case SET_SHOW:\n      return { ...state, show: action.show }\n    default:\n      return state\n  }\n}\n\nconst rootReducer = combineReducers({\n  planesConfig,\n  formationConfig,\n  viewConfig\n})\n\nexport type AppState = ReturnType<typeof rootReducer>\n\nexport default rootReducer\n","import React from 'react'\nimport ReactDOM from 'react-dom'\nimport { Provider } from 'react-redux'\nimport { createStore } from 'redux'\nimport { composeWithDevTools } from 'redux-devtools-extension'\nimport App from './components/App'\nimport * as serviceWorker from './serviceWorker'\nimport reducer from './store/reducer'\n\n\n\n\nconst store = createStore(\n    reducer, \n    composeWithDevTools()\n); \n\nReactDOM.render(<Provider store={store}><App/></Provider>, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n","import React from \"react\"\n\nimport { Container } from \"semantic-ui-react\"\nimport FormationContainer from \"./FormationContainer\"\nimport ConfigMenu from \"./ConfigMenu\"\n\nexport default () => (\n  <Container fluid style={{ marginTop: \"10px\", height: \"100vh\" }}>\n    <ConfigMenu />\n    <FormationContainer />\n  </Container>\n)\n"],"sourceRoot":""}