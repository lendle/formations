{"version":3,"sources":["formation/PlanePosition.ts","drawing/AbstractDrawer.ts","store/types.ts","constants.ts","geometry/Polar.ts","drawing/planedrawers.ts","drawing/slotdatafuns.ts","drawing/PlanesDrawer.ts","drawing/FormationDrawer.ts","components/FormationComponent.tsx","util/approxeq.ts","formation/lapwrapper.ts","formation/lap.js","formation/slotify.ts","formation/buildSlots.ts","formation/components/Component.ts","formation/components/Round.ts","formation/components/Whacker.ts","formation/components/Base.ts","formation/AbstractSlotCollection.ts","formation/buildFormation.ts","selectors/getSlotOptions.ts","formation/planes.ts","formation/buildPlanes.ts","selectors/index.ts","formation/planeify.ts","components/FormationContainer.ts","components/config/Slots.tsx","store/actions.ts","components/config/Planes.tsx","components/config/View.tsx","components/ConfigMenu.tsx","serviceWorker.js","store/reducer.ts","index.tsx","components/App.tsx"],"names":["PlanePosition","AbstractDrawer","group","this","Slotting","PlaneType","ColorOption","NumberOption","ShowOption","FormationType","PI","Math","TAU","Polar","radius","theta","Object","classCallCheck","unspin","concat","other","r1","t1","r2","t2","sqrt","cos","atan2","sin","plus","rotate","over","minus","s","floor","PLANE_SCALE_FACTOR","positionLabels","_positionLabels","defineProperty","LEAD","LT","RT","w","l","line","d3","x","d","y","OtterDrawer","_this","otterPoints","doorPoints","slotCoords","toConsumableArray","map","flatMap","planeSlotId","createClass","key","value","g","append","attr","text","plane","position","SkyvanDrawer","_this2","skyvanPoints","redLine","style","planeDrawers","_planeDrawers","OTTER","SKYVAN","buildOrderFill","_ref","stop","buildOrder","formationSlot","domain","toString","planeFill","filter","_","i","includes","radialFill","_ref2","offset","fillFunction","colorBy","BUILD_ORDER","PLANE","RADIAL","labelFunction","numberBy","formationSlotId","scaledCoord","point","type","HD","flip","scale","scaledPosition","_ref3","formation","scaledOffset","_ref4","arc","scaledPos","dockAngle","outerRadius","innerRadius","startAngle","d3theta","endAngle","planeX","planeY","highlight","transition","ease","overshoot","unhighlight","addSlot","fill","label","classed","on","call","slotG","circle","updateSlot","select","transitionOut","exit","t","remove","PlanesDrawer","args","p2c","planes","show","viewConfig","_ref$formation","FORMATION","PLANES","positions","p","Map","idx","all","length","abs","BOTH","coord","max","planeCoordinates","slotsByPlane","Array","from","d3Group","slots","slicedToArray","slotData","selectAll","data","join","enter","each","_ref5","nodes","draw","undefined","_ref6","get","selection","planeId","FormationDrawer","translate","FormationComponent","svg","allGrp","zoom","formationDrawer","planesDrawer","parseInt","scaleExtent","transform","translateBy","width","height","duration","withGroup","props","_this3","react_default","a","createElement","ref","element","React","Component","approxeq","b","eps","arguments","Number","EPSILON","combineScoreFuns","_len","funs","_key","fallback","val","fun","lapwrapper","as","bs","scoreFun","Error","badScores","score","Infinity","console","warn","result","dim","cost","cost_matrix","j","i1","j1","sum","unassignedfound","imin","prvnumfree","f","i0","k","freerow","j2","endofpath","last","low","up","min","h","umin","usubmin","v2","BIG","epsilon","rowsol","Int32Array","colsol","u","Float64Array","v","numfree","free","collist","matches","pred","loopcnt","lapcost","row","col","lap","memo","has","set","every","r","Set","size","allScores","log","slotPlane","formationSlotIds","filledSlots","slot","reverseBuildOrder","jr","slotJr","slotNumOffset","checkSlot","slotPosition","waiting","range","pos","rotation","apply","parents","parent","maxBuildOrder","Round","left","right","possibleConstructorReturn","getPrototypeOf","firstRun","_prrd","c","prrd","ceil","_positionRadiusRotationDockAngle","dockPosition","leftDockPosition","rightDockPosition","dockDistance","distanceFrom","_Round$__computeRadiu","__computeRadiusTheta","angleDelta","angleTo","error","iters","iter","lower","upper","mid","ss","Whacker","dock","hand","_this$dock","_this$dock2","psuedoSlots","_left","_right","invisibleSlots","_this$_prrd","fixedRotation","Base","_rotation","AbstractSlotCollection","_slots","computeSlots","slotsInRing","baseSize","ring","podLines","round","bridges","addRings","rings","completeRings","nextRingSlots","dockPositions","base","component","isPod","firstPods","numBridges","bridgeNum","secondPods","bridgeSecondPods","secondPod","nextDockPositions","slotGroups","slotsPerGroup","groupsWithExtraSlot","nextRing","groupNum","slotsToFill","totalSlotsInGroup","priorSlots","leftHandSlots","rightHandSlots","whackers","push","FormationImpl","components","allSlots","adjustedSlot","HU","objectSpread","parentToChildren","child","forEach","componentToWaiting","children","numWaiting","find","slotRadi","createSelector","state","formationConfig","planesConfig","_planesConfig$filter$","NONE","slotting","planeMin","FILL","planeMax","reduce","fixedMin","PlaneImpl","_AbstractSlotCollecti","inherits","reverse","countFilledSlots","filledPlanes","_ref10","_ref11","slotUnfilledPlanes","unfilledPlanes","slotsRemaining","slotsPerPlane","lead","littlePlanes","littlePlaneLabels","_ref7","minSlotsPerPlane","extras","filledLead","_ref8","remainingFilled","_ref9","_ref12","getSlots","getSlotOptions","getBaseSize","getFormation","flat","getPlanes","slotsMap","_ref13","_ref14","getAllSlots","planeAssignments","planeSlot","slotify","slotted","unslotted","planeArray","slotId","baseIds","diff","componentTheta","componentPosition","penalty","slotIds","planeify","connect","slotsOptions","formationType","dispatch","onFormationSlotsSet","formationSlots","onBaseSizeSet","onSetFormationType","_props$slotsOptions","trigger","Icon","name","formationTypes","opt","desc","HD_ABOVE","Dropdown","Item","onClick","active","baseSizes","pointing","className","Menu","Header","onChange","e","target","Divider","typeDescriptions","_typeDescriptions","PlaneMenu","_slottingDescriptions","planeConfig","setters","onPlaneSlottingSet","onPlaneTypeSet","onPlaneSlotsSet","types","SPLIT","slottingDescriptions","slottings","fluid","planeType","setPlaneType","setPlaneSlots","setPlaneSlotting","numPlanes","item","Planes_PlaneMenu","onSetColorBy","setColorBy","onSetNumberBy","setNumberBy","onSetShow","setShow","colorBys","DEFAULT","numberBys","SLOT_NUM","ConfigMenu","secondary","config_Slots","config_Planes","config_View","Boolean","window","location","hostname","match","initialPlaneState","rootReducer","combineReducers","action","store","createStore","reducer","composeWithDevTools","ReactDOM","render","es","Container","marginTop","FormationContainer","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.03dcf64f.chunk.js","sourcesContent":["enum PlanePosition {\n    LEAD='lead',\n    LT = 'lt',\n    RT = 'rt'\n}\n\nexport default PlanePosition","import { Drawer } from \"./interfaces\"\n\nexport default abstract class AbstractDrawer<Args, ReturnArgs>\n  implements Drawer<Args, ReturnArgs> {\n  group!: d3.Selection<SVGGElement, {}, null, undefined>\n\n  withGroup(group: d3.Selection<SVGGElement, {}, null, undefined>): this {\n    this.group = group\n    return this\n  }\n\n  abstract draw(args: Args, transition: any): ReturnArgs\n}\n","import PlanePosition from \"../formation/PlanePosition\"\n\nexport enum Slotting {\n  SPLIT,\n  FILL\n}\n\nexport enum PlaneType {\n  NONE,\n  OTTER,\n  SKYVAN\n}\n\nexport enum ColorOption {\n  DEFAULT,\n  PLANE,\n  BUILD_ORDER,\n  RADIAL\n}\n\nexport enum NumberOption {\n  SLOT_NUM,\n  BUILD_ORDER\n}\n\nexport enum ShowOption {\n  FORMATION,\n  PLANES,\n  BOTH\n}\n\nexport enum FormationType {\n  HD,\n  HD_ABOVE,\n  HU\n}\n\nexport interface PlaneState {\n  position: PlanePosition\n  label: string\n  slotting: Slotting\n  type: PlaneType\n  slots: number\n}\n\nexport interface FormationConfigState {\n  slots: number\n  baseSize: number\n  type: FormationType\n}\n\nexport interface ViewConfigState {\n  colorBy: ColorOption\n  numberBy: NumberOption\n  show: ShowOption\n}\n\nexport const SET_PLANE_SLOTTING = \"SET_PLANE_SLOTTING\"\ninterface SetPlaneSlottingAction {\n  type: typeof SET_PLANE_SLOTTING\n  position: PlanePosition\n  slotting: Slotting\n}\n\nexport const SET_PLANE_TYPE = \"SET_PLANE_TYPE\"\ninterface SetPlaneTypeAction {\n  type: typeof SET_PLANE_TYPE\n  position: PlanePosition\n  planeType: PlaneType\n}\n\nexport const SET_PLANE_SLOTS = \"SET_PLANE_SLOTS\"\ninterface SetPlaneSlotsAction {\n  type: typeof SET_PLANE_SLOTS\n  position: PlanePosition\n  slots: number\n}\nexport type PlanesConfigActionTypes =\n  | SetPlaneSlottingAction\n  | SetPlaneTypeAction\n  | SetPlaneSlotsAction\n\nexport const SET_FORMATION_SLOTS = \"SET_FORMATION_SLOTS\"\ninterface SetFormationSlotsAction {\n  type: typeof SET_FORMATION_SLOTS\n  slots: number\n}\nexport const SET_FORMATION_TYPE = \"SET_FORMATION_TYPE\"\ninterface SetFormationTypeAction {\n  type: typeof SET_FORMATION_TYPE\n  formationType: FormationType\n}\nexport const SET_BASE_SIZE = \"SET_BASE_SIZE\"\ninterface SetBaseSizeAction {\n  type: typeof SET_BASE_SIZE\n  baseSize: number\n}\nexport type FormationConfigActionTypes =\n  | SetFormationSlotsAction\n  | SetFormationTypeAction\n  | SetBaseSizeAction\n\nexport const SET_COLOR_BY = \"SET_COLOR_BY\"\ninterface SetColorByAction {\n  type: typeof SET_COLOR_BY\n  colorBy: ColorOption\n}\nexport const SET_NUMBER_BY = \"SET_NUMBER_BY\"\ninterface SetNumberByAction {\n  type: typeof SET_NUMBER_BY\n  numberBy: NumberOption\n}\n\nexport const SET_SHOW = \"SET_SHOW\"\ninterface SetShowAction {\n  type: typeof SET_SHOW\n  show: ShowOption\n}\nexport type ViewConfigActionTypes =\n  | SetColorByAction\n  | SetNumberByAction\n  | SetShowAction\n","export const PI = Math.PI\nexport const TAU = 2 * PI\nexport const SCALE_FACTOR = 80\n","import { PI, TAU } from \"../constants\"\n\n// polar coordinate from origin (center of base)\nexport default class Polar {\n  radius: number\n  theta: number\n  constructor(radius: number, theta: number) {\n    this.radius = radius\n    this.theta = Polar.unspin(theta)\n  }\n\n  toString() {\n    return `(r${this.radius},∠${this.theta / TAU}τ)`\n  }\n\n  //https://math.stackexchange.com/questions/1365622/adding-two-polar-vectors\n  plus(other: Polar) {\n    const { radius: r1, theta: t1 } = this\n    const { radius: r2, theta: t2 } = other\n    return new Polar(\n      Math.sqrt(r1 * r1 + r2 * r2 + 2 * r1 * r2 * Math.cos(t2 - t1)),\n      t1 + Math.atan2(r2 * Math.sin(t2 - t1), r1 + r2 * Math.cos(t2 - t1))\n    )\n  }\n\n  minus(other: Polar) {\n    return this.plus(other.rotate(PI))\n  }\n\n  rotate(theta: number) {\n    return new Polar(this.radius, this.theta + theta)\n  }\n\n  //flip coordinate over over\n  flip(over: number) {\n    return new Polar(this.radius, -this.theta - 2 * over)\n  }\n\n  // distance from other point\n  distanceFrom(other: Polar) {\n    return this.minus(other).radius\n  }\n\n  angleFrom(other: Polar) {\n    return this.minus(other).theta\n  }\n\n  angleTo(other: Polar) {\n    return other.minus(this).theta\n  }\n\n  scale(s: number) {\n    return new Polar(this.radius * s, this.theta)\n  }\n\n  // d3 treats theta = 0 as up, but in high school, theta = 0 is right\n  // also, d3 treats increasing theta as rotating clockwise, hs went counter clock wise\n  // this maps a highschool polar angle to a d3 polar angle\n  get d3theta() {\n    return Polar.unspin(-this.theta + PI / 2)\n  }\n\n  get x() {\n    return this.radius * Math.cos(this.theta)\n  }\n\n  //svg treats positive y as going down from top of page\n  get y() {\n    return -this.radius * Math.sin(this.theta)\n  }\n\n  // map theta back to [0, 2PI)\n  static unspin(theta: number) {\n    const t = Math.floor(theta / (2 * PI))\n    return theta - t * 2 * PI\n  }\n}\n","import { PlaneDrawer, SlottedPlane } from \"./interfaces\"\nimport * as d3 from \"d3\"\nimport { Selection, BaseType } from \"d3\"\nimport PlanePosition from \"../formation/PlanePosition\"\nimport { PlaneType } from \"../store/types\"\nimport { SlotData, NumDict } from \"../formation/interfaces\"\n\nconst PLANE_SCALE_FACTOR = 40\n\ntype XY = {\n  x: number;\n  y: number;\n}\n\nconst positionLabels = {\n  [PlanePosition.LEAD]: \"Lead\",\n  [PlanePosition.LT]: \"Left Trail\",\n  [PlanePosition.RT]: \"Right Trail\"\n}\n\nconst w = 1.5\nconst l = 6.5\n\nconst line = d3\n  .line<XY>()\n  .x(d => d.x * PLANE_SCALE_FACTOR)\n  .y(d => d.y * PLANE_SCALE_FACTOR)\n\nexport class OtterDrawer implements PlaneDrawer {\n  private otterPoints = [\n    { x: -w, y: -l },\n    { x: w, y: -l },\n    { x: w, y: l },\n    { x: -w, y: l },\n    { x: -w, y: -l }\n  ]\n\n  private doorPoints = [{ x: -w, y: l - 6 }, { x: -w, y: l - 2 }]\n\n  /**\n   *      23 22\n   *      21 20\n   *      19 18\n   *      17 16\n   *      15 14\n   *   6  13 12\n   *   5\n   *   4  9 11\n   *   3  8 10\n   *   2  7\n   *   1\n   *   0\n   */\n  private slotCoords = [\n    //floaters\n    ...d3.range(7).map(y => ({ x: -2, y: 6 - y })),\n    //first row in door\n    ...d3.range(3).map(y => ({ x: -1, y: 3.5 - y })),\n    //2nd row in door\n    ...d3.range(2).map(y => ({ x: 0, y: 3 - y })),\n    //divers\n    ...d3.range(6).flatMap(y => [{ x: 0.5, y: -y }, { x: -0.5, y: -y }])\n  ]\n  draw(g: Selection<SVGGElement, SlottedPlane, BaseType, any>) {\n    g.append(\"path\").attr(\"d\", line(this.otterPoints)!)\n    g.append(\"path\")\n      .attr(\"stroke-width\", 3)\n      .attr(\"d\", line(this.doorPoints)!)\n    g.append(\"text\")\n      .attr(\"text-anchor\", \"middle\")\n      .attr(\"dominant-baseline\", \"central\")\n      .attr(\"x\", 0)\n      .attr(\"y\", (-l + 1) * PLANE_SCALE_FACTOR)\n      .text(d => positionLabels[d.plane.position])\n  }\n\n  x = (d: SlotData) => this.slotCoords[d.planeSlotId].x * PLANE_SCALE_FACTOR\n  y = (d: SlotData) => this.slotCoords[d.planeSlotId].y * PLANE_SCALE_FACTOR\n}\n\nexport class SkyvanDrawer implements PlaneDrawer {\n  private skyvanPoints = [\n    { x: -w, y: -l },\n    { x: w, y: -l },\n    { x: w, y: l },\n    { x: -w, y: l },\n    { x: -w, y: -l }\n  ]\n\n  private doorPoints = [{ x: -w, y: l }, { x: w, y: l }]\n  private redLine = [{ x: -w, y: l - 4 }, { x: w, y: l - 4 }]\n\n  /**\n   *      23\n   *    21  22\n   *    19  20\n   *    17  18\n   *    15  16\n   *    13  14\n   *    11  12\n   *     9  10\n   *   ---------\n   *     7   8\n   *     5   6\n   *     3   4\n   *   0   1   2\n   *\n   */\n  private slotCoords = [\n    //1st row\n    { x: -1, y: 6 },\n    { x: 0, y: 6 },\n    { x: 1, y: 6 },\n    // the rest on back\n    ...d3.range(11).flatMap(y => [{ x: -0.5, y: 5 - y }, { x: 0.5, y: 5 - y }])\n  ]\n  draw(g: Selection<SVGGElement, SlottedPlane, BaseType, any>) {\n    g.append(\"path\").attr(\"d\", line(this.skyvanPoints)!)\n    g.append(\"path\")\n      .attr(\"stroke-width\", 3)\n      .attr(\"d\", line(this.doorPoints)!)\n\n    g.append(\"path\")\n      .attr(\"stroke-width\", 2)\n      .style(\"stroke\", \"red\")\n      .attr(\"d\", line(this.redLine)!)\n    g.append(\"text\")\n      .attr(\"text-anchor\", \"middle\")\n      .attr(\"dominant-baseline\", \"central\")\n      .attr(\"x\", 0)\n      .attr(\"y\", (-l + 1) * PLANE_SCALE_FACTOR)\n      .text(d => positionLabels[d.plane.position])\n  }\n\n  x = (d: SlotData) => this.slotCoords[d.planeSlotId].x * PLANE_SCALE_FACTOR\n  y = (d: SlotData) => this.slotCoords[d.planeSlotId].y * PLANE_SCALE_FACTOR\n}\n\nexport const planeDrawers: NumDict<PlaneDrawer> = {\n  [PlaneType.OTTER]: new OtterDrawer(),\n  [PlaneType.SKYVAN]: new SkyvanDrawer()\n}\n","import { SlotData } from \"../formation/interfaces\"\nimport * as d3 from \"d3\"\nimport PlanePosition from \"../formation/PlanePosition\"\nimport { SCALE_FACTOR, TAU, PI } from \"../constants\"\nimport { BaseType } from \"d3\"\nimport { ColorOption, NumberOption, FormationType } from \"../store/types\"\nimport { planeDrawers } from \"./planedrawers\"\nimport Polar from \"../geometry/Polar\"\n\nexport type SlotDataFun = (d: SlotData) => any\n\nconst stringRange = (stop: number): string[] =>\n  d3.range(stop).map(x => x.toString())\n\nconst buildOrderFill = ({ formationSlot: { buildOrder } }: SlotData) =>\n  d3.scaleOrdinal(d3.schemePaired).domain(stringRange(12))(\n    (buildOrder - 1).toString()\n  )\nconst planeFill = (d: SlotData) =>\n  d3\n    .scaleOrdinal(d3.schemePaired.filter((_, i) => [0, 2, 4].includes(i)))\n    .domain([PlanePosition.LEAD, PlanePosition.LT, PlanePosition.RT])(\n    d.plane.position\n  )\n\nconst radialFill = ({ formationSlot }: SlotData) => {\n  const theta = formationSlot.offset.plus(formationSlot.position).theta / TAU\n  return d3.interpolateRainbow(theta)\n}\n\nexport const fillFunction = (colorBy: ColorOption): SlotDataFun => {\n  switch (colorBy) {\n    case ColorOption.BUILD_ORDER:\n      return buildOrderFill\n    case ColorOption.PLANE:\n      return planeFill\n    case ColorOption.RADIAL:\n      return radialFill\n    default:\n      return () => null\n  }\n}\n\nexport const labelFunction = (numberBy: NumberOption) => {\n  switch (numberBy) {\n    case NumberOption.BUILD_ORDER:\n      return (d: SlotData) => d.formationSlot.buildOrder\n    default:\n      return (d: SlotData) => d.formationSlotId + 1\n  }\n}\n\nconst scaledCoord = (point: Polar, type: FormationType) =>\n  (type === FormationType.HD ? point.flip(PI / 2) : point).scale(SCALE_FACTOR)\n\nconst scaledPosition = ({\n  formationSlot: { position },\n  formation: { type }\n}: SlotData) => scaledCoord(position, type)\n\nconst scaledOffset = ({\n  formationSlot: { offset },\n  formation: { type }\n}: SlotData) => scaledCoord(offset, type)\n\nexport const arc = (d: SlotData) => {\n  const scaledPos = scaledPosition(d)\n  const dockAngle = d.formationSlot.dockAngle\n  return d3.arc()({\n    outerRadius: scaledPos.radius,\n    innerRadius: scaledPos.radius,\n    startAngle: scaledPos.d3theta - dockAngle,\n    endAngle: scaledPos.d3theta + dockAngle\n  })\n}\n\nexport const x = (d: SlotData) => scaledPosition(d).x\nexport const y = (d: SlotData) => scaledPosition(d).y\nexport const translate = (d: SlotData) =>\n  `translate(${scaledOffset(d).x},${scaledOffset(d).y})`\n\nexport const planeX = (d: SlotData) => planeDrawers[d.plane.type].x(d)\nexport const planeY = (d: SlotData) => planeDrawers[d.plane.type].y(d)\n\nexport const FORMATION_SCALE_FACTOR = 40\n\nexport const highlight = (d: SlotData) => {\n  d3.selectAll(`[formationSlotId=\"${d.formationSlotId}\"].slot circle`)\n    .transition()\n    .ease(d3.easeBack.overshoot(3))\n    .attr(\"r\", 20)\n}\nexport const unhighlight = (d: SlotData) => {\n  d3.selectAll(`[formationSlotId=\"${d.formationSlotId}\"].slot circle`)\n    .transition()\n    .ease(d3.easeBack.overshoot(3))\n    .attr(\"r\", 16)\n}\n\nexport const addSlotGroup = <E extends BaseType>(\n  selection: d3.Selection<E, SlotData, SVGGElement, any>,\n  x: SlotDataFun,\n  y: SlotDataFun,\n  fill: SlotDataFun,\n  label: SlotDataFun\n) => {\n  return selection\n    .append(\"g\")\n    .classed(\"slot\", true)\n    .on(\"mouseover\", highlight)\n    .on(\"mouseout\", unhighlight)\n    .attr(\"formationSlotId\", d => d.formationSlotId)\n    .call(slotG =>\n      slotG\n        .append(\"circle\")\n        .attr(\"cx\", x)\n        .attr(\"cy\", y)\n        .attr(\"r\", 16)\n        .attr(\"fill\", fill)\n    )\n    .call(slotG =>\n      slotG\n        .append(\"text\")\n        .attr(\"text-anchor\", \"middle\")\n        .attr(\"dominant-baseline\", \"central\")\n        .attr(\"x\", x)\n        .attr(\"y\", y)\n        .text(label)\n    )\n}\n\nexport const addSlot = <E extends BaseType>(\n  g: d3.Selection<E, SlotData, SVGGElement, any>,\n  x?: SlotDataFun,\n  y?: SlotDataFun,\n  fill?: SlotDataFun,\n  label?: SlotDataFun\n) => {\n  return g\n    .append(\"g\")\n    .classed(\"slot\", true)\n    .on(\"mouseover\", highlight)\n    .on(\"mouseout\", unhighlight)\n    .attr(\"formationSlotId\", d => d.formationSlotId)\n    .call(slotG => {\n      slotG\n        .append(\"circle\")\n        .attr(\"r\", 16)\n        .call(circle => {\n          x && circle.attr(\"cx\", x)\n          y && circle.attr(\"cy\", y)\n          fill && circle.attr(\"fill\", fill)\n        })\n      slotG\n        .append(\"text\")\n        .attr(\"text-anchor\", \"middle\")\n        .attr(\"dominant-baseline\", \"central\")\n        .call(text => {\n          x && text.attr(\"x\", x)\n          y && text.attr(\"y\", y)\n          label && text.text(label)\n        })\n    })\n}\n\nexport const updateSlot = (\n  g: d3.Transition<SVGGElement, SlotData, SVGGElement, {}>,\n  x: SlotDataFun,\n  y: SlotDataFun,\n  fill: SlotDataFun,\n  label: SlotDataFun\n) => {\n  g.select(\"g.slot circle\")\n    .attr(\"cx\", x)\n    .attr(\"cy\", y)\n    .attr(\"fill\", fill)\n\n  g.select(\"g.slot text\")\n    .attr(\"x\", x)\n    .attr(\"y\", y)\n    .text(label)\n}\n\nexport const transitionOut = (\n  exit: d3.Selection<SVGGElement, any, SVGGElement, any>,\n  t: d3.Transition<BaseType, any, any, any>\n) =>\n  exit\n    .transition(t)\n    .attr(\"transform\", \"scale(0)\")\n    .remove()\n","import { Plane, SlotData, Formation } from \"../formation/interfaces\"\nimport AbstractDrawer from \"./AbstractDrawer\"\nimport * as d3 from \"d3\"\nimport { group as d3Group } from \"d3-array\"\nimport PlanePosition from \"../formation/PlanePosition\"\nimport { ViewConfigState, ShowOption, FormationType } from \"../store/types\"\nimport Polar from \"../geometry/Polar\"\nimport { PI, SCALE_FACTOR, TAU } from \"../constants\"\nimport {\n  planeX,\n  planeY,\n  addSlot,\n  updateSlot,\n  transitionOut,\n  SlotDataFun\n} from \"./slotdatafuns\"\nimport { BaseType } from \"d3\"\nimport { planeDrawers } from \"./planedrawers\"\nimport { SlottedPlane } from \"./interfaces\"\n\nconst planeCoordinates = ({\n  planes,\n  viewConfig: { show },\n  formation: { radius, type }\n}: PlanesArgs) => {\n  switch (show) {\n    case ShowOption.FORMATION:\n    case ShowOption.PLANES: {\n      //if we're only showing planes, then draw them in a line\n      const positions = planes.map(p => p.position)\n      const positionToCoordinate = new Map(\n        [PlanePosition.LT, PlanePosition.LEAD, PlanePosition.RT]\n          .filter(p => positions.includes(p))\n          .map((p, idx, all) => {\n            const offset = idx * 300 - (all.length - 1) * 150\n            return [p, new Polar(Math.abs(offset), offset >= 0 ? 0 : PI)]\n          })\n      )\n      return positionToCoordinate\n    }\n    case ShowOption.BOTH: {\n      //if we're showing planes and formation, draw outside of formation radius\n      const positionToCoordinate = new Map(\n        planes.map(({ position, theta }) => {\n          const coord = new Polar(\n            Math.max(7, radius + 3) * SCALE_FACTOR,\n            position === PlanePosition.LEAD ? TAU / 12 : theta\n          )\n          return [\n            position,\n            type === FormationType.HD ? coord.flip(PI / 2) : coord\n          ]\n        })\n      )\n      return positionToCoordinate\n    }\n  }\n}\n\ninterface PlanesArgs {\n  slots: SlotData[]\n  planes: Plane[]\n  formation: Formation\n  viewConfig: ViewConfigState\n  fill: SlotDataFun\n  label: SlotDataFun\n}\nexport default class PlanesDrawer extends AbstractDrawer<PlanesArgs, void> {\n  draw(args: PlanesArgs, t: d3.Transition<BaseType, any, any, any>) {\n    const p2c = planeCoordinates(args)\n\n    const { fill, label } = args\n\n    // const label = (d: SlotData) => d.plane.slots[d.planeSlotId].jr.toString()\n\n    const slotsByPlane =\n      args.viewConfig.show === ShowOption.FORMATION\n        ? []\n        : Array.from(d3Group(args.slots, d => d.plane)).map(\n            ([plane, slotData]) => ({ plane, slotData })\n          )\n\n    this.group\n      .selectAll<SVGGElement, SlottedPlane>(\"g.plane\")\n      .data<SlottedPlane>(\n        slotsByPlane,\n        d => `${d.plane.position}.${d.plane.type}`\n      )\n      .join(\n        enter =>\n          enter\n            .append(\"g\")\n            .classed(\"plane\", true)\n            .each(({ plane }, i, nodes) => {\n              //draw each plane frame\n              planeDrawers[plane.type].draw(d3.select(nodes[i]), t)\n            })\n            .attr(\"transform\", \"translate(0,0) scale(0)\"),\n        undefined,\n        exit => transitionOut(exit, t)\n      )\n      .transition(t)\n      .attr(\n        \"transform\",\n        ({ plane: { position } }) =>\n          `translate(${p2c.get(position)!.x},${p2c.get(position)!.y}) scale(1)` //transition planes from center\n      )\n      .selection()\n      .selectAll<SVGGElement, SlotData>(\"g.slot\")\n      .data(d => d.slotData, d => `${d.formationSlotId}.${d.planeId}`)\n      .join(\n        addSlot, //add slots on enter without initial coordinates or label\n        undefined,\n        exit => transitionOut(exit, t)\n      )\n      .transition(t)\n      .attr(\"transform\", \"scale(1)\")\n      .call(slotG => {\n        updateSlot(slotG, planeX, planeY, fill, label)\n      })\n  }\n}\n","import { SlotData } from \"../formation/interfaces\"\nimport * as d3 from \"d3\"\nimport AbstractDrawer from \"./AbstractDrawer\"\nimport { ViewConfigState, ShowOption } from \"../store/types\"\nimport {\n  x,\n  y,\n  translate,\n  updateSlot,\n  addSlot,\n  arc,\n  transitionOut,\n  SlotDataFun\n} from \"./slotdatafuns\"\nimport { Transition, BaseType } from \"d3\"\n\ninterface FormationArgs {\n  slots: SlotData[]\n  viewConfig: ViewConfigState\n  fill: SlotDataFun\n  label: SlotDataFun\n}\nexport default class FormationDrawer extends AbstractDrawer<\n  FormationArgs,\n  void\n> {\n  draw(\n    { slots, viewConfig, fill, label }: FormationArgs,\n    t: Transition<BaseType, any, any, any>\n  ) {\n    const slotData: SlotData[] =\n      viewConfig.show === ShowOption.PLANES ? [] : slots\n\n    this.group\n      .selectAll<SVGGElement, SlotData>(\"g.slotgroup\")\n      .data<SlotData>(slotData, d => d.formationSlotId.toString())\n      .join(\n        enter =>\n          enter\n            .append(\"g\")\n            .attr(\"class\", \"slotgroup\") // slot plus grips\n            .attr(\"transform\", \"translate(0,0) scale(0)\") //start scaled down\n            .call(g => {\n              g.append(\"path\") //add the grips path\n                .attr(\"class\", \"grips\")\n                .attr(\"d\", arc)\n              addSlot(g, x, y, fill, label) //add the slot circle with fill\n            }),\n        undefined, //pass through, since we want to transition both new and old points\n        exit => transitionOut(exit, t)\n      )\n      .transition(t)\n      .attr(\"transform\", d => translate(d) + \" scale(1)\") //scale up translate\n      .call(g => {\n        //basically a no op for data that just entered\n        g.select(\"path\").attr(\"d\", arc)\n        updateSlot(g, x, y, fill, label)\n      })\n  }\n}\n","import React from \"react\"\nimport * as d3 from \"d3\"\nimport \"./FormationComponent.css\"\n\nimport { Formation, Plane, SlotData } from \"../formation/interfaces\"\nimport PlanesDrawer from \"../drawing/PlanesDrawer\"\nimport { ViewConfigState } from \"../store/types\"\nimport FormationDrawer from \"../drawing/FormationDrawer\"\nimport { SlotDataFun } from \"../drawing/slotdatafuns\"\nimport { Transition, BaseType } from \"d3\"\n\ninterface FormationProps {\n  formation: Formation\n  planes: Plane[]\n  slots: SlotData[]\n  viewConfig: ViewConfigState\n  fill: SlotDataFun\n  label: SlotDataFun\n}\nexport default class FormationComponent extends React.Component<\n  FormationProps,\n  {}\n> {\n  svg!: d3.Selection<SVGSVGElement, {}, null, undefined>\n  allGrp!: d3.Selection<SVGGElement, {}, null, undefined>\n  zoom!: d3.ZoomBehavior<SVGSVGElement, {}>\n  formationDrawer!: FormationDrawer\n  planesDrawer!: PlanesDrawer\n\n  height() {\n    return parseInt(this.svg.style(\"height\"), 10)\n  }\n\n  width() {\n    return parseInt(this.svg.style(\"width\"), 10)\n  }\n\n  componentDidMount() {\n    this.allGrp = this.svg.append(\"g\")\n\n    this.zoom = d3\n      .zoom<SVGSVGElement, {}>()\n      .scaleExtent([0.5, 2])\n      .on(\"zoom\", () => this.allGrp.attr(\"transform\", d3.event.transform))\n\n    this.svg\n      .call(this.zoom) //allows user zoom\n      .call(this.zoom.translateBy, this.width() / 2, this.height() / 2) //set initial zoom  to center\n\n    //bounding box\n    // https://bl.ocks.org/iamkevinv/0a24e9126cd2fa6b283c6f2d774b69a2\n\n    const t = d3.transition().duration(1000) as Transition<\n      BaseType,\n      any,\n      any,\n      any\n    >\n\n    this.formationDrawer = new FormationDrawer().withGroup(\n      this.allGrp.append(\"g\")\n    )\n\n    this.formationDrawer.draw(this.props, t)\n\n    this.planesDrawer = new PlanesDrawer().withGroup(this.allGrp.append(\"g\"))\n    this.planesDrawer.draw(this.props, t)\n  }\n\n  componentDidUpdate() {\n    const t = d3.transition().duration(1000) as Transition<\n      BaseType,\n      any,\n      any,\n      any\n    >\n    this.formationDrawer.draw(this.props, t)\n    this.planesDrawer.draw(this.props, t)\n  }\n\n  render() {\n    return (\n      <svg\n        width={\"100%\"}\n        height={\"100%\"}\n        ref={element => (this.svg = d3.select(element!))}\n      />\n    )\n  }\n}\n","export default function approxeq(\n  a: number,\n  b: number,\n  eps = Math.sqrt(Number.EPSILON)\n) {\n  return Math.abs(a - b) < eps\n}\n","import lap from \"./lap\"\n\ntype ScoreFun<A, B> = (a: A, b: B) => number\n\n//takes a scoreFun that takes an A and a B\n//and converts it to a function that takes i, j for i, j in [0, number of as/bs)\n//for use with lap()\nfunction cost<A, B>(as: A[], bs: B[], scoreFun: ScoreFun<A, B>) {\n  //memoize scoreFun\n  const memo = new Map<string, number>()\n  return (i: number, j: number): number => {\n    const key = `${i}.${j}`\n    if (!memo.has(key)) {\n      const a = as[i]\n      const b = bs[j]\n      memo.set(key, scoreFun(a, b))\n    }\n    return memo.get(key)!\n  }\n}\n\n/**\n * takes two arrays of things of equal length and a function that computes a score between a pair of those things\n * and assigns each thing in the first list to a thing in the second list, minimizing the sum of the scores of the assigned pairs\n * an\n * @param as\n * @param bs\n * @param scoreFun\n */\nfunction lapwrapper<A, B>(\n  as: A[],\n  bs: B[],\n  scoreFun: ScoreFun<A, B>\n): [A, B][] {\n  if (as.length !== bs.length) {\n    throw new Error(\"as and bs have diff lenghts\")\n  }\n\n  const badScores = as.flatMap(a =>\n    bs.flatMap(b => {\n      const score = scoreFun(a, b)\n      return score < 0 || score === Infinity ? [{ a, b, score }] : []\n    })\n  )\n\n  if (badScores.length > 0) {\n    console.warn(\"Scores should be non-negative and not infinity: \", badScores)\n  }\n\n  const result = lap(as.length, cost(as, bs, scoreFun))\n\n  if (\n    !result.row.every(r => r >= 0 && r < as.length) ||\n    new Set(result.row).size != as.length ||\n    result.cost === Infinity\n  ) {\n    const allScores = as.flatMap(a =>\n      bs.map(b => ({ a, b, score: scoreFun(a, b) }))\n    )\n    console.log(\"something's weird\", {\n      allScores,\n      result\n    })\n  }\n  // const assignments = result.col\n\n  // return Array.from(assignments).map((p: number, i: number) => {\n  //   const a = as[p]\n  //   const b = bs[i]\n  //   return [a, b]\n  // })\n\n  return Array.from(result.row).map((p: number, i: number) => {\n    const a = as[i]\n    const b = bs[p]\n    return [a, b]\n  })\n}\n\n/**\n * returns a function that (returns a function that) tries functions in funs(a,b) in order until it finds\n * a result that isn't undefined, and returns that. if nothing is found, fallback is used, which must be a propper\n * ScoreFun\n * @param funs score functions to try\n * @param fallback fallback score function\n */\nexport const combineScoreFuns = <A, B>(\n  ...funs: ((a: A, b: B) => number | undefined)[]\n) => (fallback: ScoreFun<A, B>) => (a: A, b: B) => {\n  for (let i = 0; i < funs.length; i++) {\n    const fun = funs[i]\n    const val = fun(a, b)\n    if (val) {\n      return val\n    }\n  }\n  return fallback(a, b)\n}\n\nexport default lapwrapper\n","//https://github.com/Fil/lap-jv\n/************************************************************************\n*\n*  lap.js -- ported to javascript from\n\n   lap.cpp\n   version 1.0 - 4 September 1996\n   author: Roy Jonker @ MagicLogic Optimization Inc.\n   e-mail: roy_jonker@magiclogic.com\n\n   Code for Linear Assignment Problem, according to\n\n   \"A Shortest Augmenting Path Algorithm for Dense and Sparse Linear\n    Assignment Problems,\" Computing 38, 325-340, 1987\n\n   by\n\n   R. Jonker and A. Volgenant, University of Amsterdam.\n\n*\n   PORTED TO JAVASCRIPT 2017-01-02 by Philippe Riviere(fil@rezo.net)\n   CHANGED 2016-05-13 by Yang Yong(yangyongeducation@163.com) in column reduction part according to\n   matlab version of LAPJV algorithm(Copyright (c) 2010, Yi Cao All rights reserved)--\n   https://www.mathworks.com/matlabcentral/fileexchange/26836-lapjv-jonker-volgenant-algorithm-for-linear-assignment-problem-v3-0:\n*\n*************************************************************************/\n\n/* This function is the jv shortest augmenting path algorithm to solve the assignment problem */\nexport default function lap(dim, cost) {\n  // input:\n  // dim        - problem size\n  // cost       - cost callback (or matrix)\n\n  // output:\n  // rowsol     - column assigned to row in solution\n  // colsol     - row assigned to column in solution\n  // u          - dual variables, row reduction numbers\n  // v          - dual variables, column reduction numbers\n\n  // convert the cost matrix (old API) to a callback (new API)\n  if (typeof cost === \"object\") {\n    var cost_matrix = cost;\n    cost = function (i, j) {\n      return cost_matrix[i][j];\n    };\n  }\n\n  var sum = 0;\n  {\n    let i1, j1;\n    for (i1 = 0; i1 < dim; i1++) {\n      for (j1 = 0; j1 < dim; j1++)\n        sum += cost(i1, j1);\n    }\n  }\n  const BIG = 10000 * (sum / dim);\n  const epsilon = sum / dim / 10000;\n  const rowsol = new Int32Array(dim),\n    colsol = new Int32Array(dim),\n    u = new Float64Array(dim),\n    v = new Float64Array(dim);\n  let unassignedfound;\n  /* row */\n  let i, imin, numfree = 0, prvnumfree, f, i0, k, freerow; // *pred, *free\n  /* col */\n  let j, j1, j2, endofpath, last, low, up; // *collist, *matches\n  /* cost */\n  let min, h, umin, usubmin, v2; // *d\n\n  const free = new Int32Array(dim); // list of unassigned rows.\n  const collist = new Int32Array(dim); // list of columns to be scanned in various ways.\n  const matches = new Int32Array(dim); // counts how many times a row could be assigned.\n  const d = new Float64Array(dim); // 'cost-distance' in augmenting path calculation.\n  const pred = new Int32Array(dim); // row-predecessor of column in augmenting/alternating path.\n\n  // init how many times a row will be assigned in the column reduction.\n  for (i = 0; i < dim; i++)\n    matches[i] = 0;\n\n  // COLUMN REDUCTION\n  for (\n    j = dim;\n    j--; // reverse order gives better results.\n\n  ) {\n    // find minimum cost over rows.\n    min = cost(0, j);\n    imin = 0;\n    for (i = 1; i < dim; i++)\n      if (cost(i, j) < min) {\n        min = cost(i, j);\n        imin = i;\n      }\n    v[j] = min;\n    if (++matches[imin] === 1) {\n      // init assignment if minimum row assigned for first time.\n      rowsol[imin] = j;\n      colsol[j] = imin;\n    } else if (v[j] < v[rowsol[imin]]) {\n      j1 = rowsol[imin];\n      rowsol[imin] = j;\n      colsol[j] = imin;\n      colsol[j1] = -1;\n    } else colsol[j] = -1; // row already assigned, column not assigned.\n  }\n\n  // REDUCTION TRANSFER\n  for (i = 0; i < dim; i++) {\n    if (\n      matches[i] === 0 // fill list of unassigned 'free' rows.\n    )\n      free[numfree++] = i;\n    else if (matches[i] === 1) {\n      // transfer reduction from rows that are assigned once.\n      j1 = rowsol[i];\n      min = BIG;\n      for (j = 0; j < dim; j++)\n        if (j !== j1)\n          if (cost(i, j) - v[j] < min + epsilon) min = cost(i, j) - v[j];\n      v[j1] = v[j1] - min;\n    }\n  }\n\n  // AUGMENTING ROW REDUCTION\n  let loopcnt = 0; // do-loop to be done twice.\n  do {\n    loopcnt++;\n\n    // scan all free rows.\n    // in some cases, a free row may be replaced with another one to be scanned next.\n    k = 0;\n    prvnumfree = numfree;\n    numfree = 0; // start list of rows still free after augmenting row reduction.\n    while (k < prvnumfree) {\n      i = free[k];\n      k++;\n\n      // find minimum and second minimum reduced cost over columns.\n      umin = cost(i, 0) - v[0];\n      j1 = 0;\n      usubmin = BIG;\n      for (j = 1; j < dim; j++) {\n        h = cost(i, j) - v[j];\n        if (h < usubmin)\n          if (h >= umin) {\n            usubmin = h;\n            j2 = j;\n          } else {\n            usubmin = umin;\n            umin = h;\n            j2 = j1;\n            j1 = j;\n          }\n      }\n\n      i0 = colsol[j1];\n      if (umin < usubmin + epsilon)\n        //         change the reduction of the minimum column to increase the minimum\n        //         reduced cost in the row to the subminimum.\n        v[j1] = v[j1] - (usubmin + epsilon - umin);\n      else if (i0 > -1) {\n        // minimum and subminimum equal.\n        // minimum column j1 is assigned.\n        // swap columns j1 and j2, as j2 may be unassigned.\n        j1 = j2;\n        i0 = colsol[j2];\n      }\n\n      // (re-)assign i to j1, possibly de-assigning an i0.\n      rowsol[i] = j1;\n      colsol[j1] = i;\n\n      if (i0 > -1)\n        if (umin < usubmin)\n          // minimum column j1 assigned earlier.\n          // put in current k, and go back to that k.\n          // continue augmenting path i - j1 with i0.\n          free[--k] = i0;\n        else\n          // no further augmenting reduction possible.\n          // store i0 in list of free rows for next phase.\n          free[numfree++] = i0;\n    }\n  } while (loopcnt < 2); // repeat once.\n\n  // AUGMENT SOLUTION for each free row.\n  for (f = 0; f < numfree; f++) {\n    freerow = free[f]; // start row of augmenting path.\n\n    // Dijkstra shortest path algorithm.\n    // runs until unassigned column added to shortest path tree.\n    for (j = dim; j--;) {\n      d[j] = cost(freerow, j) - v[j];\n      pred[j] = freerow;\n      collist[j] = j; // init column list.\n    }\n\n    low = 0; // columns in 0..low-1 are ready, now none.\n    up = 0; // columns in low..up-1 are to be scanned for current minimum, now none.\n    // columns in up..dim-1 are to be considered later to find new minimum,\n    // at this stage the list simply contains all columns\n    unassignedfound = false;\n    do {\n      if (up === low) {\n        // no more columns to be scanned for current minimum.\n        last = low - 1;\n\n        // scan columns for up..dim-1 to find all indices for which new minimum occurs.\n        // store these indices between low..up-1 (increasing up).\n        min = d[collist[up++]];\n        for (k = up; k < dim; k++) {\n          j = collist[k];\n          h = d[j];\n          if (h <= min) {\n            if (h < min) {\n              // new minimum.\n              up = low; // restart list at index low.\n              min = h;\n            }\n            // new index with same minimum, put on undex up, and extend list.\n            collist[k] = collist[up];\n            collist[up++] = j;\n          }\n        }\n        // check if any of the minimum columns happens to be unassigned.\n        // if so, we have an augmenting path right away.\n        for (k = low; k < up; k++)\n          if (colsol[collist[k]] < 0) {\n            endofpath = collist[k];\n            unassignedfound = true;\n            break;\n          }\n      }\n\n      if (!unassignedfound) {\n        // update 'distances' between freerow and all unscanned columns, via next scanned column.\n        j1 = collist[low];\n        low++;\n        i = colsol[j1];\n        h = cost(i, j1) - v[j1] - min;\n\n        for (k = up; k < dim; k++) {\n          j = collist[k];\n          v2 = cost(i, j) - v[j] - h;\n          if (v2 < d[j]) {\n            pred[j] = i;\n            if (v2 === min)\n              if (colsol[j] < 0) {\n                // new column found at same minimum value\n                // if unassigned, shortest augmenting path is complete.\n                endofpath = j;\n                unassignedfound = true;\n                break;\n              } else {\n                // else add to list to be scanned right away.\n                collist[k] = collist[up];\n                collist[up++] = j;\n              }\n            d[j] = v2;\n          }\n        }\n      }\n    } while (!unassignedfound);\n\n    // update column prices.\n    for (k = last + 1; k--;) {\n      j1 = collist[k];\n      v[j1] = v[j1] + d[j1] - min;\n    }\n\n    // reset row and column assignments along the alternating path.\n    do {\n      i = pred[endofpath];\n      colsol[endofpath] = i;\n      j1 = endofpath;\n      endofpath = rowsol[i];\n      rowsol[i] = j1;\n    } while (i !== freerow);\n  }\n\n  // calculate optimal cost.\n  let lapcost = 0;\n  for (i = dim; i--;) {\n    j = rowsol[i];\n    u[i] = cost(i, j) - v[j];\n    lapcost = lapcost + cost(i, j);\n  }\n\n  return {\n    cost: lapcost,\n    row: rowsol,\n    col: colsol,\n    u: u,\n    v: v\n  };\n}\n","import { PlaneAssignment, Formation, Plane, SlotData } from \"./interfaces\"\nimport lapwrapper from \"./lapwrapper\"\nimport * as d3 from \"d3\"\n\nconst slotPlane = (\n  plane: Plane,\n  formation: Formation,\n  formationSlotIds: number[]\n) => {\n  const score = (formationSlotId: number, planeSlotId: number) => {\n    const slot = formation.slots[formationSlotId]\n    const { reverseBuildOrder } = slot\n    const { jr } = plane.slots[planeSlotId]\n\n    const slotJr = slot.offset.plus(slot.position).y\n\n    return Math.abs(jr) * reverseBuildOrder * 100 - slotJr * jr + 1000\n  }\n\n  return lapwrapper(formationSlotIds, d3.range(plane.filledSlots), score).map(\n    ([formationSlotId, planeSlotId]) => ({ formationSlotId, planeSlotId })\n  )\n}\n\nexport default function slotify(\n  formation: Formation,\n  planes: Plane[],\n  planeAssignments: PlaneAssignment[]\n): SlotData[] {\n  return planes.flatMap((plane, planeId) => {\n    const formationSlotIds = planeAssignments\n      .filter(plane => plane.planeId === planeId)\n      .map(({ formationSlotId }) => formationSlotId)\n\n    const planeSlotAssignments = slotPlane(plane, formation, formationSlotIds)\n\n    return planeSlotAssignments.map(({ formationSlotId, planeSlotId }) => ({\n      formationSlotId,\n      formationSlot: formation.slots[formationSlotId],\n      formation,\n      planeId,\n      plane,\n      planeSlotId,\n      planeSlot: plane.slots[planeSlotId]\n    }))\n  })\n}\n","import { Formation, Plane, SlotData } from \"./interfaces\"\nimport planeify from \"./planeify\"\nimport slotify from \"./slotify\"\n\nexport default (formation: Formation, planes: Plane[]): SlotData[] => {\n  const slots = slotify(formation, planes, planeify(formation, planes))\n  return slots\n}\n","import Polar from \"../../geometry/Polar\"\n\nimport { range } from \"d3\"\nimport { FormationSlot, ComponentSlot } from \"../interfaces\"\n\nexport default abstract class Component {\n  slots: number\n  slotNumOffset: number\n\n  constructor(slots: number, slotNumOffset: number) {\n    if (slots < 0) {\n      throw new Error(`slots should be non-negative, was ${slots}`)\n    }\n    this.slots = slots\n    this.slotNumOffset = slotNumOffset\n  }\n\n  checkSlot(slot: number) {\n    if (slot < 0 || slot >= this.slots)\n      throw new Error(`slot should be in [0, ${this.slots}), was ${slot}`)\n  }\n\n  slotData(slot: number): ComponentSlot {\n    this.checkSlot(slot)\n\n    return {\n      offset: this.position(),\n      position: this.slotPosition(slot),\n      dockAngle: this.dockAngle(),\n      buildOrder: this.buildOrder(slot) + this.waiting()\n    }\n  }\n\n  allSlots(): ComponentSlot[] {\n    return range(this.slots).map(slot => this.slotData(slot))\n  }\n\n  //returns position of slot *relative to position of component*\n  slotPosition(s: number, offset = false) {\n    this.checkSlot(s)\n    const pos = new Polar(\n      this.radius(),\n      this.rotation() - 2 * s * this.dockAngle()\n    )\n    return offset ? pos.plus(this.position()) : pos\n  }\n\n  //returns position of left hand of slot *relative to center of formation*\n  dockPosition(s: number) {\n    this.checkSlot(s)\n    return this.slotPosition(s)\n      .rotate(-this.dockAngle())\n      .plus(this.position())\n  }\n\n  //how long this component is waiting before building\n  waiting(): number {\n    return Math.max(\n      ...this.parents().map(\n        parent => parent.waiting() + parent.maxBuildOrder()\n      ),\n      0\n    )\n  }\n\n  // return build order for last slot to build\n  abstract maxBuildOrder(): number\n\n  //should return build order for slot\n  abstract buildOrder(slot: number): number\n\n  //returns radius of this component\n  abstract radius(): number\n\n  //returns center of this component\n  abstract position(): Polar\n\n  //returns rotation in theta of where to place first slot\n  abstract rotation(): number\n\n  //returns angle between slot position and dock position, i.e. half of wingspan angle\n  abstract dockAngle(): number\n\n  //components this component is docked\n  abstract parents(): Component[]\n}\n","import { PI, TAU } from \"../../constants\"\nimport Component from \"./Component\"\nimport Polar from \"../../geometry/Polar\"\n\ninterface Dock {\n  c: Component\n  s: number\n}\n\nexport type PRRD = {\n  position: Polar;\n  radius: number;\n  rotation: number;\n  dockAngle: number;\n}\n\nexport default class Round extends Component {\n  left: Dock\n  right: Dock\n  firstRun: boolean\n  private _prrd: PRRD | undefined\n  /*\n  left and right are left hand and right hand docks. \n  Should be an with properties\n    - c: component\n    - s: slot index\n  */\n  constructor(slots: number, slotNumOffset: number, left: Dock, right: Dock) {\n    super(slots, slotNumOffset)\n    this.left = left\n    this.right = right\n    this.firstRun = true\n  }\n\n  parents() {\n    return Array.from(new Set([this.left.c, this.right.c]))\n  }\n\n  get prrd() {\n    if (!this._prrd) {\n      this._prrd = Round._positionRadiusRotationDockAngle(\n        this.left.c.dockPosition(this.left.s),\n        this.right.c.dockPosition(this.right.s),\n        this.slots\n      )\n    }\n    return this._prrd\n  }\n\n  //computes the centroid position\n  //component radius, and component rotation\n  //position, radius, rotation, dockangle\n  /*\n  leftDockPosition - where component's left hand dock is\n  rightDockPosition - where component's right hand dock is\n  slots - number of slots in this component\n  // parentCentroid - centroid of parent component, or center of formation. Used to pick the orien\n  */\n  static _positionRadiusRotationDockAngle(\n    leftDockPosition: Polar,\n    rightDockPosition: Polar,\n    slots: number\n  ): PRRD {\n    const dockDistance = leftDockPosition.distanceFrom(rightDockPosition)\n    const { radius, theta } = Round.__computeRadiusTheta(slots, dockDistance)\n\n    const angleDelta = leftDockPosition.angleTo(rightDockPosition)\n    const position = leftDockPosition.plus(\n      new Polar(radius, angleDelta - (PI - theta) / 2)\n    )\n\n    //the rotation is where the first slot (docking w/ right hand) goes\n    // TAU - theta is the whole arc angle, and their position is 1/(2*slots) around\n    const dockAngle = (TAU - theta) / (2 * slots)\n    const rotation = position.angleTo(rightDockPosition) - dockAngle\n\n    return { position, radius, rotation, dockAngle }\n  }\n\n  position() {\n    return this.prrd.position\n  }\n\n  radius() {\n    return this.prrd.radius\n  }\n\n  rotation() {\n    return this.prrd.rotation\n  }\n\n  dockAngle() {\n    return this.prrd.dockAngle\n  }\n\n  maxBuildOrder() {\n    return Math.ceil(this.slots / 2)\n  }\n\n  buildOrder(slot: number) {\n    this.checkSlot(slot)\n\n    //build from the ends\n    return Math.min(slot + 1, this.slots - slot)\n  }\n\n  // computes radius and angle of cutoff for a circle with the side cut off\n  // with length of the remaining curve part = s\n  // and length of flat bit = d\n  // I think it's O(-log(eps))\n  static __computeRadiusTheta(\n    s: number,\n    d: number,\n    eps = Math.sqrt(Number.EPSILON)\n  ) {\n    if (d < 0 || d > s) {\n      console.error(`d: ${d}, s: ${s}`)\n      throw new Error(\"d must be in [0, s]\")\n    }\n    var iters = 0\n    //try picking theta between lower and upper\n    function iter(lower = 0, upper = PI): number {\n      if (iters >= 100) {\n        throw new Error(\"didn't converge\")\n      }\n      iters = iters + 1\n      const mid = (upper + lower) / 2\n      // if ((upper - lower) < eps) {\n      //   return mid\n      // }\n\n      //candidate theta = mid\n      //compute radius from theta\n      const r = d / (2 * Math.sin(mid / 2))\n      //compute s from radius, theta\n      const ss = r * (TAU - mid)\n\n      if (Math.abs(ss - s) < eps) {\n        return mid\n      }\n\n      //if computed s is too big, try a bigger theta, else try smaller\n      return ss > s ? iter(mid, upper) : iter(lower, mid)\n    }\n    //iter returns theta, compute radius\n    const theta = iter()\n    return {\n      radius: s / (TAU - iter()),\n      theta: theta\n    }\n  }\n}\n","import Component from \"./Component\"\nimport Round, { PRRD } from \"./Round\"\nimport Polar from \"../../geometry/Polar\"\n\ninterface Dock {\n  c: Component\n  s: number\n}\n\nexport default class Whacker extends Component {\n  dock: Dock\n  hand: string\n  private _prrd: PRRD | undefined\n\n  /*\n  slots - \n  dock - { component, slot } this whacker is docked on\n  hand - docked with 'left' or 'right'\n \n  modeled as part of a pod (Round docked on one person) with slots * 2 + 1 slots\n  */\n  constructor(slots: number, slotNumOffset: number, dock: Dock, hand: string) {\n    super(slots, slotNumOffset)\n    this.dock = dock\n\n    if (hand !== \"left\" && hand !== \"right\")\n      throw new Error(\"Hand should be 'left' or 'right'\")\n    this.hand = hand\n  }\n\n  parents() {\n    return [this.dock.c]\n  }\n\n  //left hand dock position of the imaginary pod\n  _left() {\n    const { c, s } = this.dock\n    return this.hand === \"left\"\n      ? c.dockPosition(s)\n      : c\n          .slotPosition(s)\n          .rotate(-3 * c.dockAngle()) //move 1.5 slots to the left\n          .plus(c.position())\n  }\n\n  //right hand dock position of the imaginary pod\n  _right() {\n    const { c, s } = this.dock\n    return this.hand === \"left\"\n      ? c\n          .slotPosition(s)\n          .rotate(c.dockAngle()) //move half a slot to the right\n          .plus(c.position())\n      : c.dockPosition(s)\n  }\n\n  get prrd() {\n    if (!this._prrd) {\n      const psuedoSlots = this.slots * 2 + 1\n\n      this._prrd = Round._positionRadiusRotationDockAngle(\n        this._left(),\n        this._right(),\n        psuedoSlots\n      )\n\n      if (this.hand === \"left\") {\n        const invisibleSlots = psuedoSlots - this.slots\n        const { rotation, dockAngle } = this._prrd\n        const fixedRotation = Polar.unspin(\n          rotation - invisibleSlots * 2 * dockAngle\n        ) //rotate two slots to the right\n        this._prrd.rotation = fixedRotation\n      }\n    }\n    return this._prrd\n  }\n\n  maxBuildOrder() {\n    return this.slots\n  }\n\n  buildOrder(slot: number) {\n    this.checkSlot(slot)\n    return this.hand === \"left\" ? this.slots - slot : slot + 1\n  }\n\n  position() {\n    return this.prrd.position\n  }\n\n  radius() {\n    return this.prrd.radius\n  }\n\n  rotation() {\n    return this.prrd.rotation\n  }\n\n  dockAngle() {\n    return this.prrd.dockAngle\n  }\n}\n","import Polar from \"../../geometry/Polar\"\nimport Component from \"./Component\"\nimport { PI, TAU } from \"../../constants\"\n\nexport default class Base extends Component {\n  _rotation: number\n  constructor(slots: number, rotation = (3 * PI) / 2) {\n    super(slots, 0)\n    this._rotation = rotation\n  }\n\n  //angle to the first slot\n  rotation() {\n    return this._rotation\n  }\n\n  position() {\n    return new Polar(0, 0)\n  }\n\n  // circumference = 2 PI r\n  // circumference = # slots\n  radius() {\n    return this.slots / TAU\n  }\n\n  //angle between slot position and dock position\n  dockAngle() {\n    return TAU / (this.slots * 2)\n  }\n\n  maxBuildOrder(): number {\n    return 1\n  }\n\n  buildOrder(slot: number) {\n    this.checkSlot(slot)\n    return 1\n  }\n\n  parents() {\n    return []\n  }\n}\n","import { BaseSlot, SlotCollection, NumDict } from \"./interfaces\"\nimport arrayToDict from \"../util/arrayToDict\"\n\nexport default abstract class AbstractSlotCollection<S extends BaseSlot>\n  implements SlotCollection<S> {\n  private _slots?: S[]\n\n  protected abstract computeSlots(): S[]\n\n  get slots(): S[] {\n    if (!this._slots) {\n      this._slots = this.computeSlots()\n    }\n\n    return this._slots\n  }\n}\n","import Round from \"./components/Round\"\nimport Whacker from \"./components/Whacker\"\nimport Base from \"./components/Base\"\nimport Component from \"./components/Component\"\nimport AbstractSlotCollection from \"./AbstractSlotCollection\"\nimport { FormationSlot, Formation } from \"./interfaces\"\nimport * as d3 from \"d3\"\nimport { FormationType } from \"../store/types\"\nimport { PI } from \"../constants\"\n\ntype Ring = Component[]\ntype Dock = { c: Component; s: number }\n\n/**\n * computes the number of slots in a ring\n * @param {Number} ring index of ring,\n *         ring 0 = base,\n *         ring 1 = 1st pods\n *         ring 2 = 2nd pods\n *         ring 3 = if baseSize > 4, bridges, otherwise just pods on out\n *         ring 4 = if baseSize > 4, then pods on bridges in ring 3, otherwise just pods on podLines\n *         ring 5... pod lines on out\n */\nconst slotsInRing = (baseSize: number, ring: number): number => {\n  const podLines = Math.round(baseSize / 2)\n  const bridges = podLines > 2\n  if (ring === 0) {\n    return baseSize\n  }\n  if (ring === 1) {\n    return baseSize + podLines * 5\n  }\n  if (ring === 2) {\n    return baseSize + podLines * 10\n  }\n  if (ring === 3) {\n    return (\n      slotsInRing(baseSize, ring - 1) + (bridges ? 3 * podLines : 5 * podLines)\n    )\n  }\n  if (ring === 4) {\n    return (\n      slotsInRing(baseSize, ring - 1) + (bridges ? 5 * podLines : 5 * baseSize)\n    )\n  }\n  return (\n    slotsInRing(baseSize, 4) +\n    (ring - 4) * (bridges ? 5 * podLines : 5 * baseSize)\n  )\n}\n\n/**\n * gets dock positions for next ring given currently filled rings\n * @param rings an array of rings, 0th starting at base and going out\n */\nconst nextDockPositions = (\n  baseSize: number,\n  rings: Ring[]\n): { left: Dock; right: Dock }[] => {\n  if (rings.length > 10) {\n    throw new Error(\"somethings fucky\")\n  }\n  const bridges = baseSize !== 4\n\n  if (rings.length === 1) {\n    const base = rings[0][0]\n\n    return d3.range(0, baseSize, 2).map(slot => ({\n      left: { c: base, s: slot },\n      right: { c: base, s: (slot + baseSize - 1) % baseSize }\n    }))\n  }\n  if (\n    !bridges ||\n    rings.length === 2 ||\n    rings.length === 4 ||\n    rings.length >= 6\n  ) {\n    // if we're not using bridges\n    // or last ring (1) is 1st pods (and we need 2nd pods)\n    // or last ring (3) is bridges (and we need 2nd pods on those bridges)\n    // or we're way out (last ring >= 5)\n    // then we want pods on everything in the last ring\n    return rings[rings.length - 1].map(component => {\n      const isPod = component.slots === 5\n      return {\n        left: { c: component, s: 1 + (isPod ? 1 : 0) },\n        right: { c: component, s: 0 + (isPod ? 1 : 0) }\n      }\n    })\n  }\n  if (bridges && rings.length === 3) {\n    // ring 3 is bridges if there are bridges\n    const firstPods = rings[1]\n    const numBridges = firstPods.length\n    return d3.range(numBridges).map(bridgeNum => ({\n      left: { c: firstPods[(bridgeNum + 1) % numBridges], s: 0 },\n      right: { c: firstPods[bridgeNum], s: 3 }\n    }))\n  }\n  if (bridges && rings.length === 5) {\n    // if bridges, ring 5 is 2nd pods on bridges\n    const secondPods = rings[2]\n    const bridgeSecondPods = rings[4]\n    return secondPods\n      .flatMap((secondPod, idx) => [secondPod, bridgeSecondPods[idx]])\n      .map(component => {\n        return {\n          left: { c: component, s: component.slots === 5 ? 2 : 1 }, //5 -> pod, !5 (3) -> bridge\n          right: { c: component, s: component.slots === 5 ? 1 : 0 }\n        }\n      })\n  }\n  throw new Error(\"mmm\")\n}\n\n/**\n * this takes an array of rings starting with at least the Base, and\n * adds rings until all slots are included\n * @param {*} rings array of rings. (a ring is an array of components)\n */\nconst addRings = (slots: number, baseSize: number, rings: Ring[]): Ring[] => {\n  const completeRings = rings.length - 1\n\n  //compute slots in next ring\n  const nextRingSlots =\n    Math.min(slots, slotsInRing(baseSize, completeRings + 1)) -\n    slotsInRing(baseSize, completeRings)\n\n  if (nextRingSlots <= 0) return rings //we're done\n\n  const dockPositions = nextDockPositions(baseSize, rings)\n\n  // here a 'group' is either a pod, or, if there are less than 5 slots, two whackers\n  const slotGroups = dockPositions.length\n\n  const slotsPerGroup = Math.floor(nextRingSlots / slotGroups)\n  const groupsWithExtraSlot = nextRingSlots % slotGroups\n\n  const nextRing: Ring = dockPositions.flatMap(\n    ({ left, right }, groupNum): Ring => {\n      //slots in this group\n      const slotsToFill =\n        slotsPerGroup + (groupNum < groupsWithExtraSlot ? 1 : 0)\n      const isPod = left.c === right.c //left and right docking on same component is a pod, else bridge\n      const totalSlotsInGroup = isPod ? 5 : 3\n\n      const priorSlots =\n        slotsInRing(baseSize, completeRings) + //number of slots in prior rings\n        slotsPerGroup * groupNum + //number of slots in prior groups in this ring\n        Math.min(groupsWithExtraSlot, groupNum) //an extra slot per prior group, up to groupsWithExtraSlot\n\n      if (slotsToFill === totalSlotsInGroup) {\n        //if we have to fill the whole group, it's a pod\n        return [new Round(totalSlotsInGroup, priorSlots, left, right)]\n      } else {\n        //whackers\n        const leftHandSlots = Math.floor(slotsToFill / 2)\n        const rightHandSlots = leftHandSlots + (slotsToFill % 2) //if odd number, right hand whacker gets the extra\n        const whackers = []\n        if (leftHandSlots > 0) {\n          whackers.push(\n            new Whacker(\n              leftHandSlots,\n              priorSlots + rightHandSlots,\n              left,\n              \"left\"\n            )\n          )\n        }\n        if (rightHandSlots > 0) {\n          whackers.push(\n            new Whacker(rightHandSlots, priorSlots, right, \"right\")\n          )\n        }\n        return whackers\n      }\n    }\n  )\n  //recurse, add more rings to this prior plus this ring\n  return addRings(slots, baseSize, [...rings, nextRing])\n}\n\nclass FormationImpl extends AbstractSlotCollection<FormationSlot>\n  implements Formation {\n  components: Component[]\n  type: FormationType\n  constructor(components: Component[], type: FormationType) {\n    super()\n    this.components = components\n    this.type = type\n  }\n\n  protected computeSlots(): FormationSlot[] {\n    const reverseBuildOrder = this.reverseBuildOrder()\n    return this.components\n      .flatMap(c => c.allSlots())\n      .map((s, idx) => {\n        const adjustedSlot =\n          this.type === FormationType.HU\n            ? s\n            : {\n                ...s,\n                position: s.position.flip(PI / 2),\n                offset: s.offset.flip(PI / 2)\n              }\n        return { ...adjustedSlot, reverseBuildOrder: reverseBuildOrder[idx] }\n      })\n  }\n\n  get baseIds(): number[] {\n    return this.components\n      .find(c => c instanceof Base)!\n      .allSlots()\n      .map((s, idx) => idx)\n  }\n\n  get radius(): number {\n    const slotRadi = this.slots.map(\n      ({ position, offset }) => position.plus(offset).radius\n    )\n    return Math.max(...slotRadi)\n  }\n\n  reverseBuildOrder() {\n    const parentToChildren = new Map(\n      this.components.map(component => [component, [] as Component[]])\n    )\n\n    this.components\n      .flatMap(child => child.parents().map(parent => ({ parent, child }))) //get all parent child pairs (many to many)\n      .forEach(({ parent, child }) =>\n        parentToChildren.get(parent)!.push(child)\n      )\n\n    const componentToWaiting = new Map<Component, number>()\n\n    const waiting = (component: Component): number => {\n      if (!componentToWaiting.has(component)) {\n        const children = parentToChildren.get(component)!\n        const numWaiting = Math.max(\n          ...children.map(child => waiting(child)! + child.maxBuildOrder()),\n          0\n        )\n\n        componentToWaiting.set(component, numWaiting)\n      }\n      return componentToWaiting.get(component)!\n    }\n    // waiting(this.components[0])\n    return this.components.flatMap(c => {\n      return d3\n        .range(c.slots)\n        .map(s => waiting(c) + c.maxBuildOrder() - c.buildOrder(s))\n    })\n  }\n}\n\n/**\n * Builds a formation using the following rules until we run out of slots\n *    1) Start with the base\n *    2) Add first pods on every other base slot, starting with the slot going up jump run moving left\n *    3) Add second pods on first pods\n *    4) If base size > 4, build bridges between frist pods\n *    5) If there are bridges, build 2nd pods on bridges\n *    6) Build pods on each pod line on out to infinity!\n *\n * If there are not enough slots to complete a ring of pods/bridges, then build whackers\n *\n * @param {Number} slots slots in this formation\n * @param {Number} baseSize\n * @returns an array of Components\n */\nexport default function buildFormation(\n  slots: number,\n  baseSize: number,\n  type: FormationType\n): Formation {\n  return new FormationImpl(\n    addRings(slots, baseSize, [[new Base(baseSize)]]).flat(),\n    type\n  )\n}\n","import { createSelector } from \"reselect\"\nimport {\n  PlaneType,\n  Slotting,\n  FormationConfigState,\n  PlaneState\n} from \"../store/types\"\nimport { AppState } from \"../store/reducer\"\n\nexport const getFormationConfig = (state: AppState): FormationConfigState =>\n  state.formationConfig\nexport const getPlanesConfig = (state: AppState): PlaneState[] =>\n  state.planesConfig\n\nexport type SlotOptions = {\n  slots: number;\n  min: number;\n  max: number;\n}\n\nconst slotOptions = (\n  formationConfig: { baseSize: number; slots: number },\n  planesConfig: PlaneState[]\n): SlotOptions => {\n  const { min, max } = planesConfig\n    .filter(({ type }) => type !== PlaneType.NONE)\n    .map(({ slotting, slots }) => ({\n      //compute min/max slots on each plane\n      planeMin: slotting === Slotting.FILL ? slots : 0,\n      planeMax: slots\n    }))\n    .reduce(\n      ({ min, max }, { planeMin, planeMax }) => ({\n        //add min/max slots for all planes\n        min: min + planeMin,\n        max: max + planeMax\n      }),\n      { min: 0, max: 0 }\n    )\n\n  const fixedMin = Math.max(min, formationConfig.baseSize)\n\n  return {\n    min: fixedMin,\n    max,\n    slots: Math.max(Math.min(formationConfig.slots, max), fixedMin)\n  }\n}\n\n/**\n * computes min, max, and current number of slots based on plane and formation config\n *\n * if current slots is outside of [min, max], it is set to min or max\n */\nexport default createSelector(\n  [getFormationConfig, getPlanesConfig],\n  slotOptions\n)\n","import AbstractSlotCollection from \"./AbstractSlotCollection\"\nimport { PlaneSlot, Plane } from \"./interfaces\"\nimport PlanePosition from \"./PlanePosition\"\nimport { TAU } from \"../constants\"\nimport * as d3 from \"d3\"\nimport { PlaneType } from \"../store/types\"\n\n// abstract class AbstractPlane extends AbstractSlotCollection<PlaneSlot>\n//   implements Plane {\n//   position: PlanePosition\n//   filledSlots: number\n\n//   constructor(position: PlanePosition, filledSlots: number) {\n//     super()\n//     this.position = position\n//     this.filledSlots = filledSlots\n//   }\n\n//   get theta() {\n//     switch (this.position) {\n//       case PlanePosition.LEAD:\n//         return (3 * TAU) / 12\n//       case PlanePosition.LT:\n//         return (7 * TAU) / 12\n//       case PlanePosition.RT:\n//         return (11 * TAU) / 12\n//     }\n//   }\n// }\n\nexport class PlaneImpl extends AbstractSlotCollection<PlaneSlot>\n  implements Plane {\n  position: PlanePosition\n  filledSlots: number\n  type: PlaneType\n\n  constructor(position: PlanePosition, filledSlots: number, type: PlaneType) {\n    super()\n    this.position = position\n    this.filledSlots = filledSlots\n    this.type = type\n  }\n\n  protected computeSlots(): PlaneSlot[] {\n    return d3\n      .range(24)\n      .map(x => ({ jr: x - 14 }))\n      .reverse()\n  }\n\n  get theta() {\n    switch (this.position) {\n      case PlanePosition.LEAD:\n        return (3 * TAU) / 12\n      case PlanePosition.LT:\n        return (7 * TAU) / 12\n      case PlanePosition.RT:\n        return (11 * TAU) / 12\n    }\n  }\n}\n\n/**\n *     x x\n *     x x\n *     x x\n *     x x\n *     x x\n *  x  x x\n *  x\n *  x x x\n *  x x x\n *  x x\n *  x\n *  x\n */\n// export class Otter extends AbstractPlane {\n//   /**\n//    * jrOffset determines which slot is considered 0 up or down jump run\n//    * 3 is the 1st diver closet do the pilot just inside the door\n//    * increase to the 'centeral' slot closer to the tail, decrease to move to cockpit\n//    */\n//   private jrOffset = 1\n//   protected computeSlots(): PlaneSlot[] {\n//     const l = 6\n//     const floaters = d3\n//       .range(7)\n//       .map(y => ({ x: -2, y: l - 0.5 - y, jr: -y + this.jrOffset + 8 }))\n//     const inDoor = d3\n//       .range(3)\n//       .map(y => ({ x: -1, y: l - 3 - y, jr: -y + this.jrOffset + 1 }))\n//     const inDoor2 = d3\n//       .range(2)\n//       .map(y => ({ x: 0, y: l - 3.5 - y, jr: -y + this.jrOffset + -2 }))\n//     const divers = d3\n//       .range(6)\n//       .flatMap(y => [\n//         { x: -0.5, y: -0.5 - y, jr: -2 * y + this.jrOffset - 5 },\n//         { x: 0.5, y: -0.5 - y, jr: -2 * y + this.jrOffset - 4 }\n//       ])\n//     return [...floaters, ...inDoor, ...inDoor2, ...divers]\n//   }\n// }\n\n/**\n *     x x\n *     x x\n *     x x\n *     x x\n *     x x\n *  x  x x\n *  x\n *  x x x\n *  x x x\n *  x x\n *  x\n *  x\n */\n\n/**\n *    x\n *   x x\n *   x x\n *   x x\n *   x x\n *   x x\n *   x x\n *   x x\n *  -----\n *   x x\n *   x x\n *   x x\n *  x x x\n *\n */\n// export class Skyvan extends AbstractPlane {\n//   /**\n//    * jrOffset determines which slot is considered 0 up or down jump run\n//    * 3 is the 1st diver closet do the pilot just inside the door\n//    * increase to the 'centeral' slot closer to the tail, decrease to move to cockpit\n//    */\n//   private jrOffset = 1\n//   protected computeSlots(): PlaneSlot[] {\n//     const l = 6\n//     const door = [\n//       { x:}\n//     ]\n//     d3\n//       .range(3)\n//       .map(y => ({ x: -2, y: l - 0.5 - y, jr: -y + this.jrOffset + 8 }))\n//     const inDoor = d3\n//       .range(3)\n//       .map(y => ({ x: -1, y: l - 3 - y, jr: -y + this.jrOffset + 1 }))\n//     const inDoor2 = d3\n//       .range(2)\n//       .map(y => ({ x: 0, y: l - 3.5 - y, jr: -y + this.jrOffset + -2 }))\n//     const divers = d3\n//       .range(6)\n//       .flatMap(y => [\n//         { x: -0.5, y: -0.5 - y, jr: -2 * y + this.jrOffset - 5 },\n//         { x: 0.5, y: -0.5 - y, jr: -2 * y + this.jrOffset - 4 }\n//       ])\n//     return [...floaters, ...inDoor, ...inDoor2, ...divers]\n//   }\n// }\n\n// export const planeFactory = (\n//   position: PlanePosition,\n//   filledSlots: number,\n//   type: PlaneType\n// ): Plane => {\n//   switch (type) {\n//     case PlaneType.OTTER:\n//       return new Otter(position, filledSlots)\n//     case PlaneType.SKYVAN:\n//       throw new Error(\"SKYVAN not implemented\")\n//     case PlaneType.NONE:\n//       throw new Error(\"PlaneType is NONE\")\n//   }\n// }\n","import { PlaneState, PlaneType, Slotting } from \"../store/types\"\nimport { Plane } from \"./interfaces\"\nimport PlanePosition from \"./PlanePosition\"\nimport { PlaneImpl } from \"./planes\"\n\ntype FilledPlane = {\n  position: PlanePosition;\n  filledSlots: number;\n}\n\nconst countFilledSlots = (filledPlanes: FilledPlane[]) =>\n  filledPlanes.reduce((s, { filledSlots }) => s + filledSlots, 0)\n\n/**\n *\n * @param unfilledPlanes array of objects representing planes with slots left.\n *                       should have properties plane (lead, lt, rt), slots (total slots in plane)\n * @param slotsRemaining slots to put in unfilledPlanes\n * @param baseSize if unfilledPlanes includes lead plane, at least `baseSize` should go in it\n * @param filledPlanes array of planes already full, or partially full if slotsRemaining = 0\n */\nconst slotUnfilledPlanes = (\n  unfilledPlanes: PlaneState[],\n  slotsRemaining: number,\n  baseSize: number,\n  filledPlanes: FilledPlane[]\n): FilledPlane[] => {\n  if (unfilledPlanes.length === 0) {\n    return filledPlanes\n  }\n\n  const slotsPerPlane = slotsRemaining / unfilledPlanes.length\n\n  // if spreading remaing slots evently doesn't put enough in the lead plane for the base, fill that now\n  const lead = unfilledPlanes.find(\n    ({ position }) => position === PlanePosition.LEAD\n  )\n  if (lead && baseSize > slotsPerPlane) {\n    return slotUnfilledPlanes(\n      unfilledPlanes.filter(({ position }) => position !== PlanePosition.LEAD),\n      slotsRemaining - baseSize,\n      baseSize,\n      [{ position: PlanePosition.LEAD, filledSlots: baseSize }, ...filledPlanes]\n    )\n  }\n\n  //get planes with fewer total slots than slotsPerPlane and fill em up\n  const littlePlanes = unfilledPlanes\n    .filter(({ slots }) => slots < slotsPerPlane)\n    .map(({ position, slots }) => ({ position, filledSlots: slots }))\n\n  if (littlePlanes.length) {\n    const littlePlaneLabels = littlePlanes.map(({ position }) => position)\n    return slotUnfilledPlanes(\n      unfilledPlanes.filter(\n        ({ position }) => !littlePlaneLabels.includes(position)\n      ),\n      slotsRemaining - countFilledSlots(littlePlanes),\n      baseSize,\n      [...filledPlanes, ...littlePlanes]\n    )\n  }\n\n  // if we've gotten this far, there is room for at least slotsPerPlane on each unfilledPlane\n  const minSlotsPerPlane = Math.floor(slotsPerPlane)\n  const extras = slotsRemaining % minSlotsPerPlane\n\n  // if the lead plane is still in the mix, then always put one less on that plane\n  if (extras > 0 && lead) {\n    const filledLead = {\n      position: PlanePosition.LEAD,\n      filledSlots: minSlotsPerPlane\n    }\n    return slotUnfilledPlanes(\n      unfilledPlanes.filter(({ position }) => position !== PlanePosition.LEAD),\n      slotsRemaining - minSlotsPerPlane,\n      baseSize,\n      [filledLead, ...filledPlanes]\n    )\n  }\n\n  //okay now fill the rest. the first `extras` planes will get an extra\n  const remainingFilled = unfilledPlanes.map(({ position }, i) => ({\n    position,\n    filledSlots: minSlotsPerPlane + (extras > i ? 1 : 0)\n  }))\n\n  //phew\n  return [...filledPlanes, ...remainingFilled]\n}\n\n/**\n *\n * @param baseSize\n * @param planesConfig\n * @param slotOptions\n */\nconst filledPlanes = (\n  slots: number,\n  baseSize: number,\n  planesConfig: PlaneState[]\n): FilledPlane[] => {\n  const filledPlanes = planesConfig\n    .filter(\n      ({ type, slotting }) =>\n        type !== PlaneType.NONE && slotting === Slotting.FILL\n    )\n    .map(({ position, slots }) => ({ position, filledSlots: slots }))\n\n  const unfilledPlanes = planesConfig.filter(\n    ({ type, slotting }) =>\n      type !== PlaneType.NONE && slotting !== Slotting.FILL\n  )\n\n  return slotUnfilledPlanes(\n    unfilledPlanes,\n    slots - countFilledSlots(filledPlanes),\n    baseSize,\n    filledPlanes\n  )\n}\n\nexport default (\n  slots: number,\n  baseSize: number,\n  planesConfig: PlaneState[]\n): Plane[] => {\n  const slotsMap = new Map(\n    filledPlanes(slots, baseSize, planesConfig).map(\n      ({ position, filledSlots }) => [position, filledSlots]\n    )\n  )\n\n  return planesConfig.map(\n    ({ position, type }) =>\n      new PlaneImpl(position, slotsMap.get(position)!, type)\n  )\n}\n","import { createSelector } from \"reselect\"\nimport buildSlots from \"../formation/buildSlots\"\nimport buildFormation from \"../formation/buildFormation\"\nimport getSlotOptions from \"./getSlotOptions\"\nimport buildPlanes from \"../formation/buildPlanes\"\nimport { AppState } from \"../store/reducer\"\nimport { PlaneType, FormationType } from \"../store/types\"\n\nexport { default as getSlotOptions } from \"./getSlotOptions\"\n\nconst getSlots = (state: AppState) => getSlotOptions(state).slots\nconst getBaseSize = (state: AppState): number => state.formationConfig.baseSize\nconst getFormationType = (state: AppState): FormationType =>\n  state.formationConfig.type\nconst getFilteredPlanesConfig = (state: AppState) => {\n  return state.planesConfig.filter(({ type }) => type !== PlaneType.NONE)\n}\n\nexport const getFormation = createSelector(\n  [getSlots, getBaseSize, getFormationType],\n  buildFormation\n)\nexport const getPlanes = createSelector(\n  [getSlots, getBaseSize, getFilteredPlanesConfig],\n  buildPlanes\n)\nexport const getAllSlots = createSelector(\n  [getFormation, getPlanes],\n  buildSlots\n)\n","import { Formation, Plane, PlaneAssignment } from \"./interfaces\"\nimport PlanePosition from \"./PlanePosition\"\nimport Polar from \"../geometry/Polar\"\nimport { PI } from \"../constants\"\nimport approxeq from \"../util/approxeq\"\nimport lapwrapper, { combineScoreFuns } from \"./lapwrapper\"\nimport { range } from \"d3\"\nimport { FormationType } from \"../store/types\"\n\n/**\n * Puts people in planes\n * @param formation\n * @param planes lead assumed to be first\n */\nexport default function planeify(\n  formation: Formation,\n  planes: Plane[]\n): PlaneAssignment[] {\n  if (planes[0].position !== PlanePosition.LEAD) {\n    throw new Error(\"lead plane should be first\")\n  }\n  const LEAD_ID = 0\n\n  //slotted[planeId] = array of slot indexes for plane planeId\n  const slotted = planes.map(() => [] as number[])\n\n  // ### rule based slotting ###\n  // base in lead f\n\n  const baseScores = (slotId: number, planeId: number) => {\n    if (formation.baseIds.includes(slotId)) {\n      return planeId === LEAD_ID ? 0 : 1000\n    }\n  }\n  //todo add superfloat\n\n  // ### end rule based slotting ###\n\n  //using linear assignment problem formulation\n\n  const angleScore = (slotId: number, planeId: number) => {\n    const slot = formation.slots[slotId]\n    const plane = planes[planeId]\n    const slotPosition = slot.position.plus(slot.offset)\n    const diff = Polar.unspin(slotPosition.theta - plane.theta)\n\n    //penalize if component is on other side of jumprun from plane\n    //componentTheta is component angle rotated 90 right\n    // if > pi, right side of jump run. if < pi, left side of jump run\n    const componentTheta = Polar.unspin(slot.offset.theta - PI / 2)\n    const componentPosition =\n      approxeq(componentTheta, 0) || approxeq(componentTheta, PI)\n        ? PlanePosition.LEAD\n        : componentTheta > PI\n        ? PlanePosition.RT\n        : PlanePosition.LT\n\n    const penalty =\n      componentPosition === PlanePosition.LEAD ||\n      plane.position === PlanePosition.LEAD ||\n      componentPosition === plane.position\n        ? 0\n        : PI\n\n    return Math.min(diff, 2 * PI - diff) + penalty\n  }\n\n  //   const distScore = (slotId: number, planeId: number) => {\n  //     const slot = formation.allSlots[slotId]\n  //     const plane = planes[planeId]\n  //     return Math.abs(slot.position.plus(slot.offset).distanceFrom(new Polar(100, plane.theta)))\n  //   }\n\n  const unslotted = range(formation.slots.length)\n  const planeArray = planes.flatMap((plane, planeId) =>\n    (Array(plane.filledSlots) as number[]).fill(planeId)\n  )\n\n  const assignments = lapwrapper(\n    unslotted,\n    planeArray,\n    combineScoreFuns(baseScores)(angleScore)\n  )\n\n  assignments.forEach(([slotId, planeId]) => slotted[planeId].push(slotId))\n\n  return slotted.flatMap((slotIds, planeId) =>\n    slotIds.map(slotId => ({ formationSlotId: slotId, planeId }))\n  )\n}\n","import { connect } from \"react-redux\"\nimport FormationComponent from \"./FormationComponent\"\nimport { getFormation, getPlanes, getAllSlots } from \"../selectors\"\nimport { AppState } from \"../store/reducer\"\nimport { fillFunction, labelFunction } from \"../drawing/slotdatafuns\"\n\nconst mapStateToProps = (state: AppState) => ({\n  formation: getFormation(state),\n  planes: getPlanes(state),\n  slots: getAllSlots(state),\n  viewConfig: state.viewConfig,\n  fill: fillFunction(state.viewConfig.colorBy),\n  label: labelFunction(state.viewConfig.numberBy)\n})\n\nexport default connect(mapStateToProps)(FormationComponent)\n\n// console.log({debounceRender})\n\n// export default connect(\n//     mapStateToProps\n// )(debounceRender.debounceRender(FormationComponent, 100))\n","import React, { Dispatch } from \"react\"\nimport { connect } from \"react-redux\"\nimport { Dropdown, Icon } from \"semantic-ui-react\"\nimport { getSlotOptions } from \"../../selectors\"\nimport {\n  formationSlots,\n  baseSize,\n  setFormationType\n} from \"../../store/actions\"\nimport { FormationConfigActionTypes, FormationType } from \"../../store/types\"\nimport { AppState } from \"../../store/reducer\"\nimport { SlotOptions } from \"../../selectors/getSlotOptions\"\n\ntype Props = {\n  slotsOptions: SlotOptions;\n  baseSize: number;\n  formationType: FormationType;\n  onFormationSlotsSet: (slots: number) => void;\n  onBaseSizeSet: (size: number) => void;\n  onSetFormationType: (formationType: FormationType) => void;\n}\nconst Slots = (props: Props) => {\n  const {\n    slotsOptions: { min, max, slots },\n    baseSize,\n    formationType,\n    onFormationSlotsSet,\n    onBaseSizeSet,\n    onSetFormationType\n  } = props\n\n  const trigger = (\n    <span>\n      <Icon name=\"users\" /> <strong>Slots:</strong> {slots}\n    </span>\n  )\n\n  const formationTypes = [\n    { opt: FormationType.HD, desc: \"Head Down (from below)\" },\n    { opt: FormationType.HD_ABOVE, desc: \"Head Down (from above)\" },\n    { opt: FormationType.HU, desc: \"Head Up (from above)\" }\n  ].map(({ opt, desc }) => (\n    <Dropdown.Item\n      key={opt}\n      onClick={() => onSetFormationType(opt)}\n      active={formationType === opt}\n    >\n      {desc}\n    </Dropdown.Item>\n  ))\n\n  const baseSizes = [4, 6, 8, 10].map(bs => (\n    <Dropdown.Item\n      key={bs}\n      onClick={() => onBaseSizeSet(bs)}\n      active={baseSize === bs}\n    >\n      {bs}\n    </Dropdown.Item>\n  ))\n\n  return (\n    <Dropdown trigger={trigger} pointing className=\"link item\">\n      <Dropdown.Menu>\n        <Dropdown.Header>Slots</Dropdown.Header>\n        <Dropdown.Item>\n          <span>{min} </span>\n          <input\n            type=\"range\"\n            value={slots}\n            min={min}\n            max={max}\n            onChange={e => onFormationSlotsSet(parseInt(e.target.value))}\n          />\n          <span> {max}</span>\n        </Dropdown.Item>\n        <Dropdown.Divider />\n        <Dropdown.Header>Base Size</Dropdown.Header>\n        {baseSizes}\n        <Dropdown.Divider />\n        <Dropdown.Header>Formation Type</Dropdown.Header>\n        {formationTypes}\n      </Dropdown.Menu>\n    </Dropdown>\n  )\n}\n\nconst mapStateToProps = (state: AppState) => ({\n  slotsOptions: getSlotOptions(state),\n  baseSize: state.formationConfig.baseSize,\n  formationType: state.formationConfig.type\n})\n\nconst mapDispatchToProps = (\n  dispatch: Dispatch<FormationConfigActionTypes>\n) => ({\n  onFormationSlotsSet: (slots: number) => dispatch(formationSlots(slots)),\n  onBaseSizeSet: (size: number) => dispatch(baseSize(size)),\n  onSetFormationType: (type: FormationType) => dispatch(setFormationType(type))\n})\n\nexport default connect(\n  mapStateToProps,\n  mapDispatchToProps\n)(Slots)\n","import {\n  SET_BASE_SIZE,\n  SET_FORMATION_SLOTS,\n  SET_FORMATION_TYPE,\n  SET_PLANE_SLOTTING,\n  SET_PLANE_TYPE,\n  SET_PLANE_SLOTS,\n  SET_COLOR_BY,\n  SET_NUMBER_BY,\n  ColorOption,\n  NumberOption,\n  PlaneType,\n  Slotting,\n  FormationType,\n  FormationConfigActionTypes,\n  PlanesConfigActionTypes,\n  ViewConfigActionTypes,\n  ShowOption,\n  SET_SHOW\n} from \"./types\"\nimport PlanePosition from \"../formation/PlanePosition\"\n\nexport const baseSize = (baseSize: number): FormationConfigActionTypes => ({\n  type: SET_BASE_SIZE,\n  baseSize\n})\n\nexport const formationSlots = (slots: number): FormationConfigActionTypes => ({\n  type: SET_FORMATION_SLOTS,\n  slots\n})\n\nexport const setFormationType = (\n  formationType: FormationType\n): FormationConfigActionTypes => ({\n  type: SET_FORMATION_TYPE,\n  formationType\n})\n\nexport const setPlaneSlotting = (\n  position: PlanePosition,\n  slotting: Slotting\n): PlanesConfigActionTypes => ({\n  type: SET_PLANE_SLOTTING,\n  position,\n  slotting\n})\n\nexport const setPlaneType = (\n  position: PlanePosition,\n  type: PlaneType\n): PlanesConfigActionTypes => ({\n  type: SET_PLANE_TYPE,\n  position,\n  planeType: type\n})\n\nexport const setPlaneSlots = (\n  position: PlanePosition,\n  slots: number\n): PlanesConfigActionTypes => ({\n  type: SET_PLANE_SLOTS,\n  position,\n  slots\n})\n\nexport const setColorBy = (colorBy: ColorOption): ViewConfigActionTypes => ({\n  type: SET_COLOR_BY,\n  colorBy\n})\n\nexport const setNumberBy = (numberBy: NumberOption): ViewConfigActionTypes => ({\n  type: SET_NUMBER_BY,\n  numberBy\n})\n\nexport const setShow = (show: ShowOption): ViewConfigActionTypes => ({\n  type: SET_SHOW,\n  show\n})\n","import React, { Dispatch } from \"react\"\nimport { connect } from \"react-redux\"\nimport { Dropdown, Icon } from \"semantic-ui-react\"\nimport {\n  PlaneType,\n  Slotting,\n  PlanesConfigActionTypes,\n  PlaneState\n} from \"../../store/types\"\nimport {\n  setPlaneType,\n  setPlaneSlots,\n  setPlaneSlotting\n} from \"../../store/actions\"\nimport PlanePosition from \"../../formation/PlanePosition\"\nimport { AppState } from \"../../store/reducer\"\n\ntype Setters = {\n  onPlaneTypeSet: (plane: PlanePosition, type: PlaneType) => void;\n  onPlaneSlotsSet: (plane: PlanePosition, slots: number) => void;\n  onPlaneSlottingSet: (plane: PlanePosition, slotting: Slotting) => void;\n}\n\ntype PlaneMenuProps = {\n  planeConfig: PlaneState;\n  setters: Setters;\n}\n\nconst typeDescriptions = {\n  [PlaneType.OTTER]: \"Otter\",\n  [PlaneType.SKYVAN]: \"Skyvan\",\n  [PlaneType.NONE]: \"None\"\n}\n\nconst PlaneMenu = (props: PlaneMenuProps) => {\n  const { planeConfig, setters } = props\n  const { position, label, slotting, type, slots } = planeConfig\n  const { onPlaneSlottingSet, onPlaneTypeSet, onPlaneSlotsSet } = setters\n  const trigger = (\n    <div>\n      <strong>{label}</strong>: {typeDescriptions[type]}\n      {type !== PlaneType.NONE\n        ? `, ${slots} slots, ${\n            slotting === Slotting.FILL ? \"filled\" : \"slotted evenly\"\n          }`\n        : null}\n    </div>\n  )\n\n  const types =\n    position === PlanePosition.LEAD\n      ? [PlaneType.OTTER, PlaneType.SKYVAN]\n      : [PlaneType.OTTER, PlaneType.SKYVAN, PlaneType.NONE]\n\n  const { FILL, SPLIT } = Slotting\n  const slottingDescriptions = {\n    [FILL]: \"Fill plane\",\n    [SPLIT]: \"Split evenly\"\n  }\n  const slottings = [SPLIT, FILL]\n\n  return (\n    <Dropdown.Item>\n      <Dropdown trigger={trigger} fluid>\n        <Dropdown.Menu>\n          <Dropdown.Header>Type</Dropdown.Header>\n          {types.map(t => (\n            <Dropdown.Item\n              key={t}\n              onClick={() => onPlaneTypeSet(position, t)}\n              active={type === t}\n            >\n              {typeDescriptions[t]}\n            </Dropdown.Item>\n          ))}\n          <Dropdown.Divider />\n          <Dropdown.Header>Slotting</Dropdown.Header>\n          {slottings.map(s => (\n            <Dropdown.Item\n              key={s}\n              onClick={() => onPlaneSlottingSet(position, s)}\n              active={slotting === s}\n            >\n              {slottingDescriptions[s]}\n            </Dropdown.Item>\n          ))}\n          <Dropdown.Divider />\n          <Dropdown.Header>Slots: {slots}</Dropdown.Header>\n          <Dropdown.Item>\n            <span>0 </span>\n            <input\n              type=\"range\"\n              value={slots}\n              min={0}\n              max={30}\n              onChange={e =>\n                onPlaneSlotsSet(position, parseInt(e.target.value))\n              }\n            />\n            <span> {30}</span>\n          </Dropdown.Item>\n        </Dropdown.Menu>\n      </Dropdown>\n    </Dropdown.Item>\n  )\n}\n\ntype PlanesProps = {\n  planesConfig: PlaneState[];\n  setters: Setters;\n}\nconst Planes = (props: PlanesProps) => {\n  const { planesConfig, setters } = props\n\n  const numPlanes = planesConfig.filter(({ type }) => type !== PlaneType.NONE)\n    .length\n\n  const trigger = (\n    <span>\n      <Icon name=\"plane\" /> <strong>Planes:</strong> {numPlanes}\n    </span>\n  )\n\n  return (\n    <Dropdown trigger={trigger} item>\n      <Dropdown.Menu>\n        {planesConfig.map(planeConfig => (\n          <PlaneMenu\n            key={planeConfig.position}\n            planeConfig={planeConfig}\n            setters={setters}\n          />\n        ))}\n      </Dropdown.Menu>\n    </Dropdown>\n  )\n}\n\nconst mapStateToProps = (state: AppState) => ({\n  planesConfig: state.planesConfig\n})\n\nconst mapDispatchToProps = (dispatch: Dispatch<PlanesConfigActionTypes>) => ({\n  setters: {\n    onPlaneTypeSet: (plane: PlanePosition, type: PlaneType) =>\n      dispatch(setPlaneType(plane, type)),\n    onPlaneSlotsSet: (plane: PlanePosition, slots: number) =>\n      dispatch(setPlaneSlots(plane, slots)),\n    onPlaneSlottingSet: (plane: PlanePosition, slotting: Slotting) =>\n      dispatch(setPlaneSlotting(plane, slotting))\n  }\n})\n\nexport default connect(\n  mapStateToProps,\n  mapDispatchToProps\n)(Planes)\n","import React, { Dispatch } from \"react\"\nimport { connect } from \"react-redux\"\nimport { Dropdown, Icon } from \"semantic-ui-react\"\nimport {\n  ColorOption,\n  NumberOption,\n  ShowOption,\n  ViewConfigState,\n  ViewConfigActionTypes\n} from \"../../store/types\"\nimport { setColorBy, setNumberBy, setShow } from \"../../store/actions\"\nimport { AppState } from \"../../store/reducer\"\n\ntype Props = {\n  viewConfig: ViewConfigState;\n  onSetColorBy: (opt: ColorOption) => void;\n  onSetNumberBy: (opt: NumberOption) => void;\n  onSetShow: (opt: ShowOption) => void;\n}\nconst View = (props: Props) => {\n  const { viewConfig, onSetColorBy, onSetNumberBy, onSetShow } = props\n\n  const trigger = (\n    <span>\n      <Icon name=\"eye\" /> <strong>View</strong>\n    </span>\n  )\n\n  const colorBys = [\n    { opt: ColorOption.DEFAULT, desc: \"Default\" },\n    { opt: ColorOption.PLANE, desc: \"Plane\" },\n    { opt: ColorOption.BUILD_ORDER, desc: \"Build Order\" },\n    { opt: ColorOption.RADIAL, desc: \"Radial\" }\n  ].map(({ opt, desc }) => (\n    <Dropdown.Item\n      key={opt}\n      onClick={() => onSetColorBy(opt)}\n      active={viewConfig.colorBy === opt}\n    >\n      {desc}\n    </Dropdown.Item>\n  ))\n\n  const numberBys = [\n    { opt: NumberOption.SLOT_NUM, desc: \"Slot Number\" },\n    { opt: NumberOption.BUILD_ORDER, desc: \"Build Order\" }\n  ].map(({ opt, desc }) => (\n    <Dropdown.Item\n      key={opt}\n      onClick={() => onSetNumberBy(opt)}\n      active={viewConfig.numberBy === opt}\n    >\n      {desc}\n    </Dropdown.Item>\n  ))\n\n  const show = [\n    { opt: ShowOption.FORMATION, desc: \"Formation\" },\n    { opt: ShowOption.PLANES, desc: \"Planes\" },\n    { opt: ShowOption.BOTH, desc: \"Formation & Planes\" }\n  ].map(({ opt, desc }) => (\n    <Dropdown.Item\n      key={opt}\n      onClick={() => onSetShow(opt)}\n      active={viewConfig.show === opt}\n    >\n      {desc}\n    </Dropdown.Item>\n  ))\n\n  return (\n    <Dropdown trigger={trigger} item>\n      <Dropdown.Menu>\n        <Dropdown.Header>Color by</Dropdown.Header>\n        {colorBys}\n        <Dropdown.Divider />\n        <Dropdown.Header>Number by</Dropdown.Header>\n        {numberBys}\n        <Dropdown.Divider />\n        <Dropdown.Header>Show</Dropdown.Header>\n        {show}\n      </Dropdown.Menu>\n    </Dropdown>\n  )\n}\n\nconst mapStateToProps = (state: AppState) => ({\n  viewConfig: state.viewConfig\n})\n\nconst mapDispatchToProps = (dispatch: Dispatch<ViewConfigActionTypes>) => ({\n  onSetColorBy: (colorBy: ColorOption) => dispatch(setColorBy(colorBy)),\n  onSetNumberBy: (numberBy: NumberOption) => dispatch(setNumberBy(numberBy)),\n  onSetShow: (show: ShowOption) => dispatch(setShow(show))\n})\n\nexport default connect(\n  mapStateToProps,\n  mapDispatchToProps\n)(View)\n","import React from \"react\"\nimport { Menu } from \"semantic-ui-react\"\nimport Slots from \"./config/Slots\"\nimport Planes from \"./config/Planes\"\nimport View from \"./config/View\"\n\nexport default () => (\n  <Menu size={\"mini\"} secondary>\n    <Slots />\n    <Planes />\n    <View />\n  </Menu>\n)\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import { combineReducers } from \"redux\"\nimport PlanePosition from \"../formation/PlanePosition\"\nimport {\n  PlaneState,\n  FormationConfigState,\n  ViewConfigState,\n  Slotting,\n  PlaneType,\n  FormationType,\n  ColorOption,\n  NumberOption,\n  SET_PLANE_SLOTTING,\n  SET_PLANE_SLOTS,\n  SET_PLANE_TYPE,\n  SET_FORMATION_SLOTS,\n  SET_FORMATION_TYPE,\n  SET_COLOR_BY,\n  SET_NUMBER_BY,\n  SET_BASE_SIZE,\n  FormationConfigActionTypes,\n  PlanesConfigActionTypes,\n  ViewConfigActionTypes,\n  SET_SHOW,\n  ShowOption\n} from \"./types\"\n\nconst { LEAD, LT, RT } = PlanePosition\n\nconst initialPlaneState: PlaneState[] = [\n  {\n    position: LEAD,\n    label: \"Lead\",\n    slotting: Slotting.SPLIT,\n    type: PlaneType.OTTER,\n    slots: 23\n  },\n  {\n    position: LT,\n    label: \"Left Trail\",\n    slotting: Slotting.SPLIT,\n    type: PlaneType.NONE,\n    slots: 23\n  },\n  {\n    position: RT,\n    label: \"Right Trail\",\n    slotting: Slotting.SPLIT,\n    type: PlaneType.OTTER,\n    slots: 23\n  }\n]\n\nconst planesConfig = (\n  state = initialPlaneState,\n  action: PlanesConfigActionTypes\n): PlaneState[] => {\n  const position = action.position\n  return state.map(p => {\n    if (p.position !== position) {\n      return p\n    }\n    switch (action.type) {\n      case SET_PLANE_SLOTTING:\n        return { ...p, slotting: action.slotting }\n      case SET_PLANE_SLOTS:\n        return { ...p, slots: action.slots }\n      case SET_PLANE_TYPE:\n        return { ...p, type: action.planeType }\n      default:\n        return p\n    }\n  })\n}\n\nconst formationConfig = (\n  state = { slots: 42, baseSize: 6, type: FormationType.HD },\n  action: FormationConfigActionTypes\n): FormationConfigState => {\n  switch (action.type) {\n    case SET_FORMATION_SLOTS:\n      return { ...state, slots: action.slots }\n    case SET_BASE_SIZE:\n      return { ...state, baseSize: action.baseSize }\n    case SET_FORMATION_TYPE:\n      return { ...state, type: action.formationType }\n    default:\n      return state\n  }\n}\n\nconst viewConfig = (\n  state = {\n    colorBy: ColorOption.PLANE,\n    numberBy: NumberOption.SLOT_NUM,\n    show: ShowOption.BOTH\n  },\n  action: ViewConfigActionTypes\n): ViewConfigState => {\n  switch (action.type) {\n    case SET_COLOR_BY:\n      return { ...state, colorBy: action.colorBy }\n    case SET_NUMBER_BY:\n      return { ...state, numberBy: action.numberBy }\n    case SET_SHOW:\n      return { ...state, show: action.show }\n    default:\n      return state\n  }\n}\n\nconst rootReducer = combineReducers({\n  planesConfig,\n  formationConfig,\n  viewConfig\n})\n\nexport type AppState = ReturnType<typeof rootReducer>\n\nexport default rootReducer\n","import React from \"react\"\nimport ReactDOM from \"react-dom\"\nimport { Provider } from \"react-redux\"\nimport { createStore } from \"redux\"\nimport { composeWithDevTools } from \"redux-devtools-extension\"\nimport App from \"./components/App\"\nimport * as serviceWorker from \"./serviceWorker\"\nimport reducer from \"./store/reducer\"\n\nconst store = createStore(reducer, composeWithDevTools())\n\nReactDOM.render(\n  <Provider store={store}>\n    <App />\n  </Provider>,\n  document.getElementById(\"root\")\n)\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister()\n","import React from \"react\"\n\nimport { Container } from \"semantic-ui-react\"\nimport FormationContainer from \"./FormationContainer\"\nimport ConfigMenu from \"./ConfigMenu\"\n\nexport default () => (\n  <Container fluid style={{ marginTop: \"10px\", height: \"100vh\" }}>\n    <ConfigMenu />\n    <FormationContainer />\n  </Container>\n)\n"],"sourceRoot":""}